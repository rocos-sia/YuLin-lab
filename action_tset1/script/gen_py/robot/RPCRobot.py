#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def power_on(self, block):
        """
        Parameters:
         - block

        """
        pass

    def power_off(self, block):
        """
        Parameters:
         - block

        """
        pass

    def enable(self, block):
        """
        Parameters:
         - block

        """
        pass

    def disable(self, block):
        """
        Parameters:
         - block

        """
        pass

    def shutdown(self, block):
        """
        Parameters:
         - block

        """
        pass

    def stop(self, block):
        """
        Parameters:
         - block

        """
        pass

    def pause(self, block):
        """
        Parameters:
         - block

        """
        pass

    def resume(self, block):
        """
        Parameters:
         - block

        """
        pass

    def run_program(self, name, block):
        """
        Parameters:
         - name
         - block

        """
        pass

    def set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        """
        Parameters:
         - name
         - tool_offset
         - payload
         - inertia_tensor

        """
        pass

    def get_tool_load(self):
        pass

    def get_tcp_offset(self):
        pass

    def set_wobj(self, name, wobj):
        """
        Parameters:
         - name
         - wobj

        """
        pass

    def set_wobj_offset(self, wobj):
        """
        Parameters:
         - wobj

        """
        pass

    def get_wobj(self):
        pass

    def cal_fkine(self, joints_position, tool, wobj):
        """
        Parameters:
         - joints_position
         - tool
         - wobj

        """
        pass

    def cal_ikine(self, p, q_near, tool, wobj):
        """
        Parameters:
         - p
         - q_near
         - tool
         - wobj

        """
        pass

    def set_standard_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def set_tool_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def get_standard_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_tool_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_config_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_standard_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_tool_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_standard_analog_current_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        pass

    def read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        pass

    def read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        pass

    def write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        pass

    def write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        pass

    def tool_read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        pass

    def tool_read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        pass

    def tool_read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        pass

    def tool_write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def tool_write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        pass

    def tool_write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        pass

    def read_raw_data_can(self):
        pass

    def write_raw_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        pass

    def get_function_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_function_digital_out(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_bool_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_word_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_float_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def write_bool_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def write_word_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def write_float_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def movej(self, joints_list, v, a, r, block, op):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op

        """
        pass

    def movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        pass

    def movej2(self, joints_list, v, a, r, block, op):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op

        """
        pass

    def movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        pass

    def movel(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        pass

    def movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        pass

    def move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        pass

    def tcp_move(self, pose_offset, v, a, r, block, op):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - block
         - op

        """
        pass

    def tcp_move_2p(self, p1, p2, v, a, r, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - block
         - op

        """
        pass

    def spline(self, pose_list, v, a, tool, wobj, block, op):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op

        """
        pass

    def speedj(self, joints_list, a, time, block):
        """
        Parameters:
         - joints_list
         - a
         - time
         - block

        """
        pass

    def speedl(self, pose_list, a, time, block):
        """
        Parameters:
         - pose_list
         - a
         - time
         - block

        """
        pass

    def speed_stop(self, block):
        """
        Parameters:
         - block

        """
        pass

    def servoj(self, joints_list, v, a, kp, kd):
        """
        Parameters:
         - joints_list
         - v
         - a
         - kp
         - kd

        """
        pass

    def servoj_pose(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - kp
         - kd

        """
        pass

    def servol(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - kp
         - kd

        """
        pass

    def teach_mode(self, block):
        """
        Parameters:
         - block

        """
        pass

    def end_teach_mode(self, block):
        """
        Parameters:
         - block

        """
        pass

    def modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        """
        Parameters:
         - ip
         - slave_number
         - signal_address
         - signal_type
         - signal_name

        """
        pass

    def modbus_delete_signal(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        pass

    def modbus_read(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        pass

    def modbus_write(self, signal_name, value):
        """
        Parameters:
         - signal_name
         - value

        """
        pass

    def modbus_set_frequency(self, signal_name, frequence):
        """
        Parameters:
         - signal_name
         - frequence

        """
        pass

    def get_last_error(self):
        pass

    def get_noneblock_taskstate(self, id):
        """
        Parameters:
         - id

        """
        pass

    def log_info(self, message):
        """
        Parameters:
         - message

        """
        pass

    def log_error(self, message):
        """
        Parameters:
         - message

        """
        pass

    def simulation(self, sim, block):
        """
        Parameters:
         - sim
         - block

        """
        pass

    def speed(self, val):
        """
        Parameters:
         - val

        """
        pass

    def get_robot_state(self):
        pass

    def get_flange_pose(self):
        pass

    def get_flange_speed(self):
        pass

    def get_flange_acceleration(self):
        pass

    def get_tcp_pose(self):
        pass

    def get_tcp_speed(self):
        pass

    def get_tcp_acceleration(self):
        pass

    def get_tcp_force(self):
        pass

    def get_actual_joints_position(self):
        pass

    def get_target_joints_position(self):
        pass

    def get_actual_joints_speed(self):
        pass

    def get_target_joints_speed(self):
        pass

    def get_actual_joints_acceleration(self):
        pass

    def get_target_joints_acceleration(self):
        pass

    def get_actual_joints_torque(self):
        pass

    def get_target_joints_torque(self):
        pass

    def stop_record_track(self):
        pass

    def start_record_track(self, name):
        """
        Parameters:
         - name

        """
        pass

    def collision_detect(self, value):
        """
        Parameters:
         - value

        """
        pass

    def replay(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def set_load_data(self, value):
        """
        Parameters:
         - value

        """
        pass

    def fc_start(self):
        pass

    def fc_stop(self):
        pass

    def fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        """
        Parameters:
         - direction
         - ref_ft
         - damp
         - max_vel
         - number_list
         - tool
         - wobj
         - value

        """
        pass

    def fc_move(self):
        pass

    def fc_guard_act(self, direction, ref_ft, tool, wobj, type):
        """
        Parameters:
         - direction
         - ref_ft
         - tool
         - wobj
         - type

        """
        pass

    def fc_guard_deact(self):
        pass

    def fc_force_set_value(self, direction, ref_ft):
        """
        Parameters:
         - direction
         - ref_ft

        """
        pass

    def fc_wait_pos(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_vel(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_ft(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_logic(self, value):
        """
        Parameters:
         - value

        """
        pass

    def fc_get_ft(self):
        pass

    def fc_mode_is_active(self):
        pass

    def start_realtime_mode(self):
        pass

    def end_realtime_mode(self):
        pass

    def enable_speed_optimization(self, block):
        """
        Parameters:
         - block

        """
        pass

    def disable_speed_optimization(self, block):
        """
        Parameters:
         - block

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def power_on(self, block):
        """
        Parameters:
         - block

        """
        self.send_power_on(block)
        return self.recv_power_on()

    def send_power_on(self, block):
        self._oprot.writeMessageBegin('power_on', TMessageType.CALL, self._seqid)
        args = power_on_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_power_on(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = power_on_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "power_on failed: unknown result")

    def power_off(self, block):
        """
        Parameters:
         - block

        """
        self.send_power_off(block)
        return self.recv_power_off()

    def send_power_off(self, block):
        self._oprot.writeMessageBegin('power_off', TMessageType.CALL, self._seqid)
        args = power_off_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_power_off(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = power_off_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "power_off failed: unknown result")

    def enable(self, block):
        """
        Parameters:
         - block

        """
        self.send_enable(block)
        return self.recv_enable()

    def send_enable(self, block):
        self._oprot.writeMessageBegin('enable', TMessageType.CALL, self._seqid)
        args = enable_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable failed: unknown result")

    def disable(self, block):
        """
        Parameters:
         - block

        """
        self.send_disable(block)
        return self.recv_disable()

    def send_disable(self, block):
        self._oprot.writeMessageBegin('disable', TMessageType.CALL, self._seqid)
        args = disable_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable failed: unknown result")

    def shutdown(self, block):
        """
        Parameters:
         - block

        """
        self.send_shutdown(block)
        return self.recv_shutdown()

    def send_shutdown(self, block):
        self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
        args = shutdown_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shutdown(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shutdown_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shutdown failed: unknown result")

    def stop(self, block):
        """
        Parameters:
         - block

        """
        self.send_stop(block)
        return self.recv_stop()

    def send_stop(self, block):
        self._oprot.writeMessageBegin('stop', TMessageType.CALL, self._seqid)
        args = stop_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop failed: unknown result")

    def pause(self, block):
        """
        Parameters:
         - block

        """
        self.send_pause(block)
        return self.recv_pause()

    def send_pause(self, block):
        self._oprot.writeMessageBegin('pause', TMessageType.CALL, self._seqid)
        args = pause_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pause(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pause_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pause failed: unknown result")

    def resume(self, block):
        """
        Parameters:
         - block

        """
        self.send_resume(block)
        return self.recv_resume()

    def send_resume(self, block):
        self._oprot.writeMessageBegin('resume', TMessageType.CALL, self._seqid)
        args = resume_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resume failed: unknown result")

    def run_program(self, name, block):
        """
        Parameters:
         - name
         - block

        """
        self.send_run_program(name, block)
        return self.recv_run_program()

    def send_run_program(self, name, block):
        self._oprot.writeMessageBegin('run_program', TMessageType.CALL, self._seqid)
        args = run_program_args()
        args.name = name
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_run_program(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = run_program_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "run_program failed: unknown result")

    def set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        """
        Parameters:
         - name
         - tool_offset
         - payload
         - inertia_tensor

        """
        self.send_set_tool_data(name, tool_offset, payload, inertia_tensor)
        return self.recv_set_tool_data()

    def send_set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        self._oprot.writeMessageBegin('set_tool_data', TMessageType.CALL, self._seqid)
        args = set_tool_data_args()
        args.name = name
        args.tool_offset = tool_offset
        args.payload = payload
        args.inertia_tensor = inertia_tensor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_tool_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_tool_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_tool_data failed: unknown result")

    def get_tool_load(self):
        self.send_get_tool_load()
        return self.recv_get_tool_load()

    def send_get_tool_load(self):
        self._oprot.writeMessageBegin('get_tool_load', TMessageType.CALL, self._seqid)
        args = get_tool_load_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_load(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_load_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_load failed: unknown result")

    def get_tcp_offset(self):
        self.send_get_tcp_offset()
        return self.recv_get_tcp_offset()

    def send_get_tcp_offset(self):
        self._oprot.writeMessageBegin('get_tcp_offset', TMessageType.CALL, self._seqid)
        args = get_tcp_offset_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_offset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_offset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_offset failed: unknown result")

    def set_wobj(self, name, wobj):
        """
        Parameters:
         - name
         - wobj

        """
        self.send_set_wobj(name, wobj)
        return self.recv_set_wobj()

    def send_set_wobj(self, name, wobj):
        self._oprot.writeMessageBegin('set_wobj', TMessageType.CALL, self._seqid)
        args = set_wobj_args()
        args.name = name
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_wobj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_wobj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_wobj failed: unknown result")

    def set_wobj_offset(self, wobj):
        """
        Parameters:
         - wobj

        """
        self.send_set_wobj_offset(wobj)
        return self.recv_set_wobj_offset()

    def send_set_wobj_offset(self, wobj):
        self._oprot.writeMessageBegin('set_wobj_offset', TMessageType.CALL, self._seqid)
        args = set_wobj_offset_args()
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_wobj_offset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_wobj_offset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_wobj_offset failed: unknown result")

    def get_wobj(self):
        self.send_get_wobj()
        return self.recv_get_wobj()

    def send_get_wobj(self):
        self._oprot.writeMessageBegin('get_wobj', TMessageType.CALL, self._seqid)
        args = get_wobj_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_wobj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_wobj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_wobj failed: unknown result")

    def cal_fkine(self, joints_position, tool, wobj):
        """
        Parameters:
         - joints_position
         - tool
         - wobj

        """
        self.send_cal_fkine(joints_position, tool, wobj)
        return self.recv_cal_fkine()

    def send_cal_fkine(self, joints_position, tool, wobj):
        self._oprot.writeMessageBegin('cal_fkine', TMessageType.CALL, self._seqid)
        args = cal_fkine_args()
        args.joints_position = joints_position
        args.tool = tool
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cal_fkine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cal_fkine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cal_fkine failed: unknown result")

    def cal_ikine(self, p, q_near, tool, wobj):
        """
        Parameters:
         - p
         - q_near
         - tool
         - wobj

        """
        self.send_cal_ikine(p, q_near, tool, wobj)
        return self.recv_cal_ikine()

    def send_cal_ikine(self, p, q_near, tool, wobj):
        self._oprot.writeMessageBegin('cal_ikine', TMessageType.CALL, self._seqid)
        args = cal_ikine_args()
        args.p = p
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cal_ikine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cal_ikine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cal_ikine failed: unknown result")

    def set_standard_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_standard_digital_out(num, value, block)
        return self.recv_set_standard_digital_out()

    def send_set_standard_digital_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_standard_digital_out', TMessageType.CALL, self._seqid)
        args = set_standard_digital_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_standard_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_standard_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_standard_digital_out failed: unknown result")

    def set_tool_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_tool_digital_out(num, value, block)
        return self.recv_set_tool_digital_out()

    def send_set_tool_digital_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_tool_digital_out', TMessageType.CALL, self._seqid)
        args = set_tool_digital_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_tool_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_tool_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_tool_digital_out failed: unknown result")

    def get_standard_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_digital_in(num)
        return self.recv_get_standard_digital_in()

    def send_get_standard_digital_in(self, num):
        self._oprot.writeMessageBegin('get_standard_digital_in', TMessageType.CALL, self._seqid)
        args = get_standard_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_digital_in failed: unknown result")

    def get_tool_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_tool_digital_in(num)
        return self.recv_get_tool_digital_in()

    def send_get_tool_digital_in(self, num):
        self._oprot.writeMessageBegin('get_tool_digital_in', TMessageType.CALL, self._seqid)
        args = get_tool_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_digital_in failed: unknown result")

    def get_config_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_config_digital_in(num)
        return self.recv_get_config_digital_in()

    def send_get_config_digital_in(self, num):
        self._oprot.writeMessageBegin('get_config_digital_in', TMessageType.CALL, self._seqid)
        args = get_config_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_config_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_config_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_digital_in failed: unknown result")

    def get_standard_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_analog_voltage_in(num)
        return self.recv_get_standard_analog_voltage_in()

    def send_get_standard_analog_voltage_in(self, num):
        self._oprot.writeMessageBegin('get_standard_analog_voltage_in', TMessageType.CALL, self._seqid)
        args = get_standard_analog_voltage_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_analog_voltage_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_analog_voltage_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_analog_voltage_in failed: unknown result")

    def get_tool_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_tool_analog_voltage_in(num)
        return self.recv_get_tool_analog_voltage_in()

    def send_get_tool_analog_voltage_in(self, num):
        self._oprot.writeMessageBegin('get_tool_analog_voltage_in', TMessageType.CALL, self._seqid)
        args = get_tool_analog_voltage_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_analog_voltage_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_analog_voltage_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_analog_voltage_in failed: unknown result")

    def get_standard_analog_current_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_analog_current_in(num)
        return self.recv_get_standard_analog_current_in()

    def send_get_standard_analog_current_in(self, num):
        self._oprot.writeMessageBegin('get_standard_analog_current_in', TMessageType.CALL, self._seqid)
        args = get_standard_analog_current_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_analog_current_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_analog_current_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_analog_current_in failed: unknown result")

    def read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        self.send_read_raw_data_485(len)
        return self.recv_read_raw_data_485()

    def send_read_raw_data_485(self, len):
        self._oprot.writeMessageBegin('read_raw_data_485', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_args()
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485 failed: unknown result")

    def read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        self.send_read_raw_data_485_ht(head, tail)
        return self.recv_read_raw_data_485_ht()

    def send_read_raw_data_485_ht(self, head, tail):
        self._oprot.writeMessageBegin('read_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_ht_args()
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485_ht failed: unknown result")

    def read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        self.send_read_raw_data_485_h(head, len)
        return self.recv_read_raw_data_485_h()

    def send_read_raw_data_485_h(self, head, len):
        self._oprot.writeMessageBegin('read_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_h_args()
        args.head = head
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485_h failed: unknown result")

    def write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_write_raw_data_485(data)
        return self.recv_write_raw_data_485()

    def send_write_raw_data_485(self, data):
        self._oprot.writeMessageBegin('write_raw_data_485', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485 failed: unknown result")

    def write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        self.send_write_raw_data_485_h(data, head)
        return self.recv_write_raw_data_485_h()

    def send_write_raw_data_485_h(self, data, head):
        self._oprot.writeMessageBegin('write_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_h_args()
        args.data = data
        args.head = head
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485_h failed: unknown result")

    def write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        self.send_write_raw_data_485_ht(data, head, tail)
        return self.recv_write_raw_data_485_ht()

    def send_write_raw_data_485_ht(self, data, head, tail):
        self._oprot.writeMessageBegin('write_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_ht_args()
        args.data = data
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485_ht failed: unknown result")

    def tool_read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        self.send_tool_read_raw_data_485(len)
        return self.recv_tool_read_raw_data_485()

    def send_tool_read_raw_data_485(self, len):
        self._oprot.writeMessageBegin('tool_read_raw_data_485', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_args()
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485 failed: unknown result")

    def tool_read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        self.send_tool_read_raw_data_485_h(head, len)
        return self.recv_tool_read_raw_data_485_h()

    def send_tool_read_raw_data_485_h(self, head, len):
        self._oprot.writeMessageBegin('tool_read_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_h_args()
        args.head = head
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485_h failed: unknown result")

    def tool_read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        self.send_tool_read_raw_data_485_ht(head, tail)
        return self.recv_tool_read_raw_data_485_ht()

    def send_tool_read_raw_data_485_ht(self, head, tail):
        self._oprot.writeMessageBegin('tool_read_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_ht_args()
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485_ht failed: unknown result")

    def tool_write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_tool_write_raw_data_485(data)
        return self.recv_tool_write_raw_data_485()

    def send_tool_write_raw_data_485(self, data):
        self._oprot.writeMessageBegin('tool_write_raw_data_485', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485 failed: unknown result")

    def tool_write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        self.send_tool_write_raw_data_485_h(data, head)
        return self.recv_tool_write_raw_data_485_h()

    def send_tool_write_raw_data_485_h(self, data, head):
        self._oprot.writeMessageBegin('tool_write_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_h_args()
        args.data = data
        args.head = head
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485_h failed: unknown result")

    def tool_write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        self.send_tool_write_raw_data_485_ht(data, head, tail)
        return self.recv_tool_write_raw_data_485_ht()

    def send_tool_write_raw_data_485_ht(self, data, head, tail):
        self._oprot.writeMessageBegin('tool_write_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_ht_args()
        args.data = data
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485_ht failed: unknown result")

    def read_raw_data_can(self):
        self.send_read_raw_data_can()
        return self.recv_read_raw_data_can()

    def send_read_raw_data_can(self):
        self._oprot.writeMessageBegin('read_raw_data_can', TMessageType.CALL, self._seqid)
        args = read_raw_data_can_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_can failed: unknown result")

    def write_raw_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        self.send_write_raw_data_can(id, data)
        return self.recv_write_raw_data_can()

    def send_write_raw_data_can(self, id, data):
        self._oprot.writeMessageBegin('write_raw_data_can', TMessageType.CALL, self._seqid)
        args = write_raw_data_can_args()
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_can failed: unknown result")

    def get_function_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_digital_in(num)
        return self.recv_get_function_digital_in()

    def send_get_function_digital_in(self, num):
        self._oprot.writeMessageBegin('get_function_digital_in', TMessageType.CALL, self._seqid)
        args = get_function_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_digital_in failed: unknown result")

    def get_function_digital_out(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_digital_out(num)
        return self.recv_get_function_digital_out()

    def send_get_function_digital_out(self, num):
        self._oprot.writeMessageBegin('get_function_digital_out', TMessageType.CALL, self._seqid)
        args = get_function_digital_out_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_digital_out failed: unknown result")

    def read_bool_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_bool_reg(num)
        return self.recv_read_bool_reg()

    def send_read_bool_reg(self, num):
        self._oprot.writeMessageBegin('read_bool_reg', TMessageType.CALL, self._seqid)
        args = read_bool_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_bool_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_bool_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_bool_reg failed: unknown result")

    def read_word_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_word_reg(num)
        return self.recv_read_word_reg()

    def send_read_word_reg(self, num):
        self._oprot.writeMessageBegin('read_word_reg', TMessageType.CALL, self._seqid)
        args = read_word_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_word_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_word_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_word_reg failed: unknown result")

    def read_float_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_float_reg(num)
        return self.recv_read_float_reg()

    def send_read_float_reg(self, num):
        self._oprot.writeMessageBegin('read_float_reg', TMessageType.CALL, self._seqid)
        args = read_float_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_float_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_float_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_float_reg failed: unknown result")

    def write_bool_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_bool_reg(num, value)
        return self.recv_write_bool_reg()

    def send_write_bool_reg(self, num, value):
        self._oprot.writeMessageBegin('write_bool_reg', TMessageType.CALL, self._seqid)
        args = write_bool_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_bool_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_bool_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_bool_reg failed: unknown result")

    def write_word_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_word_reg(num, value)
        return self.recv_write_word_reg()

    def send_write_word_reg(self, num, value):
        self._oprot.writeMessageBegin('write_word_reg', TMessageType.CALL, self._seqid)
        args = write_word_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_word_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_word_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_word_reg failed: unknown result")

    def write_float_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_float_reg(num, value)
        return self.recv_write_float_reg()

    def send_write_float_reg(self, num, value):
        self._oprot.writeMessageBegin('write_float_reg', TMessageType.CALL, self._seqid)
        args = write_float_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_float_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_float_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_float_reg failed: unknown result")

    def movej(self, joints_list, v, a, r, block, op):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op

        """
        self.send_movej(joints_list, v, a, r, block, op)
        return self.recv_movej()

    def send_movej(self, joints_list, v, a, r, block, op):
        self._oprot.writeMessageBegin('movej', TMessageType.CALL, self._seqid)
        args = movej_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej failed: unknown result")

    def movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        self.send_movej_pose(p, v, a, r, q_near, tool, wobj, block, op)
        return self.recv_movej_pose()

    def send_movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op):
        self._oprot.writeMessageBegin('movej_pose', TMessageType.CALL, self._seqid)
        args = movej_pose_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej_pose failed: unknown result")

    def movej2(self, joints_list, v, a, r, block, op):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op

        """
        self.send_movej2(joints_list, v, a, r, block, op)
        return self.recv_movej2()

    def send_movej2(self, joints_list, v, a, r, block, op):
        self._oprot.writeMessageBegin('movej2', TMessageType.CALL, self._seqid)
        args = movej2_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej2 failed: unknown result")

    def movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        self.send_movej_pose2(p, v, a, r, q_near, tool, wobj, block, op)
        return self.recv_movej_pose2()

    def send_movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op):
        self._oprot.writeMessageBegin('movej_pose2', TMessageType.CALL, self._seqid)
        args = movej_pose2_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej_pose2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_pose2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej_pose2 failed: unknown result")

    def movel(self, p, v, a, r, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        self.send_movel(p, v, a, r, q_near, tool, wobj, block, op)
        return self.recv_movel()

    def send_movel(self, p, v, a, r, q_near, tool, wobj, block, op):
        self._oprot.writeMessageBegin('movel', TMessageType.CALL, self._seqid)
        args = movel_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movel failed: unknown result")

    def movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        self.send_movec(p1, p2, v, a, r, mode, q_near, tool, wobj, block, op)
        return self.recv_movec()

    def send_movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        self._oprot.writeMessageBegin('movec', TMessageType.CALL, self._seqid)
        args = movec_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.mode = mode
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movec failed: unknown result")

    def move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op

        """
        self.send_move_circle(p1, p2, v, a, r, mode, q_near, tool, wobj, block, op)
        return self.recv_move_circle()

    def send_move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op):
        self._oprot.writeMessageBegin('move_circle', TMessageType.CALL, self._seqid)
        args = move_circle_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.mode = mode
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_circle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_circle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_circle failed: unknown result")

    def tcp_move(self, pose_offset, v, a, r, block, op):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - block
         - op

        """
        self.send_tcp_move(pose_offset, v, a, r, block, op)
        return self.recv_tcp_move()

    def send_tcp_move(self, pose_offset, v, a, r, block, op):
        self._oprot.writeMessageBegin('tcp_move', TMessageType.CALL, self._seqid)
        args = tcp_move_args()
        args.pose_offset = pose_offset
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcp_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcp_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tcp_move failed: unknown result")

    def tcp_move_2p(self, p1, p2, v, a, r, block, op):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - block
         - op

        """
        self.send_tcp_move_2p(p1, p2, v, a, r, block, op)
        return self.recv_tcp_move_2p()

    def send_tcp_move_2p(self, p1, p2, v, a, r, block, op):
        self._oprot.writeMessageBegin('tcp_move_2p', TMessageType.CALL, self._seqid)
        args = tcp_move_2p_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcp_move_2p(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcp_move_2p_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tcp_move_2p failed: unknown result")

    def spline(self, pose_list, v, a, tool, wobj, block, op):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op

        """
        self.send_spline(pose_list, v, a, tool, wobj, block, op)
        return self.recv_spline()

    def send_spline(self, pose_list, v, a, tool, wobj, block, op):
        self._oprot.writeMessageBegin('spline', TMessageType.CALL, self._seqid)
        args = spline_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spline failed: unknown result")

    def speedj(self, joints_list, a, time, block):
        """
        Parameters:
         - joints_list
         - a
         - time
         - block

        """
        self.send_speedj(joints_list, a, time, block)
        return self.recv_speedj()

    def send_speedj(self, joints_list, a, time, block):
        self._oprot.writeMessageBegin('speedj', TMessageType.CALL, self._seqid)
        args = speedj_args()
        args.joints_list = joints_list
        args.a = a
        args.time = time
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speedj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speedj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speedj failed: unknown result")

    def speedl(self, pose_list, a, time, block):
        """
        Parameters:
         - pose_list
         - a
         - time
         - block

        """
        self.send_speedl(pose_list, a, time, block)
        return self.recv_speedl()

    def send_speedl(self, pose_list, a, time, block):
        self._oprot.writeMessageBegin('speedl', TMessageType.CALL, self._seqid)
        args = speedl_args()
        args.pose_list = pose_list
        args.a = a
        args.time = time
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speedl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speedl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speedl failed: unknown result")

    def speed_stop(self, block):
        """
        Parameters:
         - block

        """
        self.send_speed_stop(block)
        return self.recv_speed_stop()

    def send_speed_stop(self, block):
        self._oprot.writeMessageBegin('speed_stop', TMessageType.CALL, self._seqid)
        args = speed_stop_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speed_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speed_stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speed_stop failed: unknown result")

    def servoj(self, joints_list, v, a, kp, kd):
        """
        Parameters:
         - joints_list
         - v
         - a
         - kp
         - kd

        """
        self.send_servoj(joints_list, v, a, kp, kd)
        return self.recv_servoj()

    def send_servoj(self, joints_list, v, a, kp, kd):
        self._oprot.writeMessageBegin('servoj', TMessageType.CALL, self._seqid)
        args = servoj_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.kp = kp
        args.kd = kd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servoj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servoj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servoj failed: unknown result")

    def servoj_pose(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - kp
         - kd

        """
        self.send_servoj_pose(pose_list, v, a, q_near, tool, wobj, kp, kd)
        return self.recv_servoj_pose()

    def send_servoj_pose(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        self._oprot.writeMessageBegin('servoj_pose', TMessageType.CALL, self._seqid)
        args = servoj_pose_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.kp = kp
        args.kd = kd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servoj_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servoj_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servoj_pose failed: unknown result")

    def servol(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - kp
         - kd

        """
        self.send_servol(pose_list, v, a, q_near, tool, wobj, kp, kd)
        return self.recv_servol()

    def send_servol(self, pose_list, v, a, q_near, tool, wobj, kp, kd):
        self._oprot.writeMessageBegin('servol', TMessageType.CALL, self._seqid)
        args = servol_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.kp = kp
        args.kd = kd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servol failed: unknown result")

    def teach_mode(self, block):
        """
        Parameters:
         - block

        """
        self.send_teach_mode(block)
        return self.recv_teach_mode()

    def send_teach_mode(self, block):
        self._oprot.writeMessageBegin('teach_mode', TMessageType.CALL, self._seqid)
        args = teach_mode_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_teach_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = teach_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "teach_mode failed: unknown result")

    def end_teach_mode(self, block):
        """
        Parameters:
         - block

        """
        self.send_end_teach_mode(block)
        return self.recv_end_teach_mode()

    def send_end_teach_mode(self, block):
        self._oprot.writeMessageBegin('end_teach_mode', TMessageType.CALL, self._seqid)
        args = end_teach_mode_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_teach_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_teach_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "end_teach_mode failed: unknown result")

    def modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        """
        Parameters:
         - ip
         - slave_number
         - signal_address
         - signal_type
         - signal_name

        """
        self.send_modbus_add_signal(ip, slave_number, signal_address, signal_type, signal_name)
        return self.recv_modbus_add_signal()

    def send_modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        self._oprot.writeMessageBegin('modbus_add_signal', TMessageType.CALL, self._seqid)
        args = modbus_add_signal_args()
        args.ip = ip
        args.slave_number = slave_number
        args.signal_address = signal_address
        args.signal_type = signal_type
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_add_signal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_add_signal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_add_signal failed: unknown result")

    def modbus_delete_signal(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        self.send_modbus_delete_signal(signal_name)
        return self.recv_modbus_delete_signal()

    def send_modbus_delete_signal(self, signal_name):
        self._oprot.writeMessageBegin('modbus_delete_signal', TMessageType.CALL, self._seqid)
        args = modbus_delete_signal_args()
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_delete_signal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_delete_signal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_delete_signal failed: unknown result")

    def modbus_read(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        self.send_modbus_read(signal_name)
        return self.recv_modbus_read()

    def send_modbus_read(self, signal_name):
        self._oprot.writeMessageBegin('modbus_read', TMessageType.CALL, self._seqid)
        args = modbus_read_args()
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_read failed: unknown result")

    def modbus_write(self, signal_name, value):
        """
        Parameters:
         - signal_name
         - value

        """
        self.send_modbus_write(signal_name, value)
        return self.recv_modbus_write()

    def send_modbus_write(self, signal_name, value):
        self._oprot.writeMessageBegin('modbus_write', TMessageType.CALL, self._seqid)
        args = modbus_write_args()
        args.signal_name = signal_name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_write failed: unknown result")

    def modbus_set_frequency(self, signal_name, frequence):
        """
        Parameters:
         - signal_name
         - frequence

        """
        self.send_modbus_set_frequency(signal_name, frequence)
        self.recv_modbus_set_frequency()

    def send_modbus_set_frequency(self, signal_name, frequence):
        self._oprot.writeMessageBegin('modbus_set_frequency', TMessageType.CALL, self._seqid)
        args = modbus_set_frequency_args()
        args.signal_name = signal_name
        args.frequence = frequence
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_set_frequency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_set_frequency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_last_error(self):
        self.send_get_last_error()
        return self.recv_get_last_error()

    def send_get_last_error(self):
        self._oprot.writeMessageBegin('get_last_error', TMessageType.CALL, self._seqid)
        args = get_last_error_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_last_error(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_last_error_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_last_error failed: unknown result")

    def get_noneblock_taskstate(self, id):
        """
        Parameters:
         - id

        """
        self.send_get_noneblock_taskstate(id)
        return self.recv_get_noneblock_taskstate()

    def send_get_noneblock_taskstate(self, id):
        self._oprot.writeMessageBegin('get_noneblock_taskstate', TMessageType.CALL, self._seqid)
        args = get_noneblock_taskstate_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_noneblock_taskstate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_noneblock_taskstate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_noneblock_taskstate failed: unknown result")

    def log_info(self, message):
        """
        Parameters:
         - message

        """
        self.send_log_info(message)
        self.recv_log_info()

    def send_log_info(self, message):
        self._oprot.writeMessageBegin('log_info', TMessageType.CALL, self._seqid)
        args = log_info_args()
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_log_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = log_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def log_error(self, message):
        """
        Parameters:
         - message

        """
        self.send_log_error(message)
        self.recv_log_error()

    def send_log_error(self, message):
        self._oprot.writeMessageBegin('log_error', TMessageType.CALL, self._seqid)
        args = log_error_args()
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_log_error(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = log_error_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def simulation(self, sim, block):
        """
        Parameters:
         - sim
         - block

        """
        self.send_simulation(sim, block)
        return self.recv_simulation()

    def send_simulation(self, sim, block):
        self._oprot.writeMessageBegin('simulation', TMessageType.CALL, self._seqid)
        args = simulation_args()
        args.sim = sim
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simulation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simulation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simulation failed: unknown result")

    def speed(self, val):
        """
        Parameters:
         - val

        """
        self.send_speed(val)
        return self.recv_speed()

    def send_speed(self, val):
        self._oprot.writeMessageBegin('speed', TMessageType.CALL, self._seqid)
        args = speed_args()
        args.val = val
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speed failed: unknown result")

    def get_robot_state(self):
        self.send_get_robot_state()
        return self.recv_get_robot_state()

    def send_get_robot_state(self):
        self._oprot.writeMessageBegin('get_robot_state', TMessageType.CALL, self._seqid)
        args = get_robot_state_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_robot_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_robot_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_robot_state failed: unknown result")

    def get_flange_pose(self):
        self.send_get_flange_pose()
        return self.recv_get_flange_pose()

    def send_get_flange_pose(self):
        self._oprot.writeMessageBegin('get_flange_pose', TMessageType.CALL, self._seqid)
        args = get_flange_pose_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_pose failed: unknown result")

    def get_flange_speed(self):
        self.send_get_flange_speed()
        return self.recv_get_flange_speed()

    def send_get_flange_speed(self):
        self._oprot.writeMessageBegin('get_flange_speed', TMessageType.CALL, self._seqid)
        args = get_flange_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_speed failed: unknown result")

    def get_flange_acceleration(self):
        self.send_get_flange_acceleration()
        return self.recv_get_flange_acceleration()

    def send_get_flange_acceleration(self):
        self._oprot.writeMessageBegin('get_flange_acceleration', TMessageType.CALL, self._seqid)
        args = get_flange_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_acceleration failed: unknown result")

    def get_tcp_pose(self):
        self.send_get_tcp_pose()
        return self.recv_get_tcp_pose()

    def send_get_tcp_pose(self):
        self._oprot.writeMessageBegin('get_tcp_pose', TMessageType.CALL, self._seqid)
        args = get_tcp_pose_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_pose failed: unknown result")

    def get_tcp_speed(self):
        self.send_get_tcp_speed()
        return self.recv_get_tcp_speed()

    def send_get_tcp_speed(self):
        self._oprot.writeMessageBegin('get_tcp_speed', TMessageType.CALL, self._seqid)
        args = get_tcp_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_speed failed: unknown result")

    def get_tcp_acceleration(self):
        self.send_get_tcp_acceleration()
        return self.recv_get_tcp_acceleration()

    def send_get_tcp_acceleration(self):
        self._oprot.writeMessageBegin('get_tcp_acceleration', TMessageType.CALL, self._seqid)
        args = get_tcp_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_acceleration failed: unknown result")

    def get_tcp_force(self):
        self.send_get_tcp_force()
        return self.recv_get_tcp_force()

    def send_get_tcp_force(self):
        self._oprot.writeMessageBegin('get_tcp_force', TMessageType.CALL, self._seqid)
        args = get_tcp_force_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_force(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_force_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_force failed: unknown result")

    def get_actual_joints_position(self):
        self.send_get_actual_joints_position()
        return self.recv_get_actual_joints_position()

    def send_get_actual_joints_position(self):
        self._oprot.writeMessageBegin('get_actual_joints_position', TMessageType.CALL, self._seqid)
        args = get_actual_joints_position_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_position(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_position_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_position failed: unknown result")

    def get_target_joints_position(self):
        self.send_get_target_joints_position()
        return self.recv_get_target_joints_position()

    def send_get_target_joints_position(self):
        self._oprot.writeMessageBegin('get_target_joints_position', TMessageType.CALL, self._seqid)
        args = get_target_joints_position_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_position(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_position_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_position failed: unknown result")

    def get_actual_joints_speed(self):
        self.send_get_actual_joints_speed()
        return self.recv_get_actual_joints_speed()

    def send_get_actual_joints_speed(self):
        self._oprot.writeMessageBegin('get_actual_joints_speed', TMessageType.CALL, self._seqid)
        args = get_actual_joints_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_speed failed: unknown result")

    def get_target_joints_speed(self):
        self.send_get_target_joints_speed()
        return self.recv_get_target_joints_speed()

    def send_get_target_joints_speed(self):
        self._oprot.writeMessageBegin('get_target_joints_speed', TMessageType.CALL, self._seqid)
        args = get_target_joints_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_speed failed: unknown result")

    def get_actual_joints_acceleration(self):
        self.send_get_actual_joints_acceleration()
        return self.recv_get_actual_joints_acceleration()

    def send_get_actual_joints_acceleration(self):
        self._oprot.writeMessageBegin('get_actual_joints_acceleration', TMessageType.CALL, self._seqid)
        args = get_actual_joints_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_acceleration failed: unknown result")

    def get_target_joints_acceleration(self):
        self.send_get_target_joints_acceleration()
        return self.recv_get_target_joints_acceleration()

    def send_get_target_joints_acceleration(self):
        self._oprot.writeMessageBegin('get_target_joints_acceleration', TMessageType.CALL, self._seqid)
        args = get_target_joints_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_acceleration failed: unknown result")

    def get_actual_joints_torque(self):
        self.send_get_actual_joints_torque()
        return self.recv_get_actual_joints_torque()

    def send_get_actual_joints_torque(self):
        self._oprot.writeMessageBegin('get_actual_joints_torque', TMessageType.CALL, self._seqid)
        args = get_actual_joints_torque_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_torque(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_torque_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_torque failed: unknown result")

    def get_target_joints_torque(self):
        self.send_get_target_joints_torque()
        return self.recv_get_target_joints_torque()

    def send_get_target_joints_torque(self):
        self._oprot.writeMessageBegin('get_target_joints_torque', TMessageType.CALL, self._seqid)
        args = get_target_joints_torque_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_torque(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_torque_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_torque failed: unknown result")

    def stop_record_track(self):
        self.send_stop_record_track()
        return self.recv_stop_record_track()

    def send_stop_record_track(self):
        self._oprot.writeMessageBegin('stop_record_track', TMessageType.CALL, self._seqid)
        args = stop_record_track_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_record_track(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_record_track_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop_record_track failed: unknown result")

    def start_record_track(self, name):
        """
        Parameters:
         - name

        """
        self.send_start_record_track(name)
        return self.recv_start_record_track()

    def send_start_record_track(self, name):
        self._oprot.writeMessageBegin('start_record_track', TMessageType.CALL, self._seqid)
        args = start_record_track_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_record_track(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_record_track_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_record_track failed: unknown result")

    def collision_detect(self, value):
        """
        Parameters:
         - value

        """
        self.send_collision_detect(value)
        return self.recv_collision_detect()

    def send_collision_detect(self, value):
        self._oprot.writeMessageBegin('collision_detect', TMessageType.CALL, self._seqid)
        args = collision_detect_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_collision_detect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = collision_detect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "collision_detect failed: unknown result")

    def replay(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_replay(name, value)
        return self.recv_replay()

    def send_replay(self, name, value):
        self._oprot.writeMessageBegin('replay', TMessageType.CALL, self._seqid)
        args = replay_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_replay(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = replay_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "replay failed: unknown result")

    def set_load_data(self, value):
        """
        Parameters:
         - value

        """
        self.send_set_load_data(value)
        return self.recv_set_load_data()

    def send_set_load_data(self, value):
        self._oprot.writeMessageBegin('set_load_data', TMessageType.CALL, self._seqid)
        args = set_load_data_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_load_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_load_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_load_data failed: unknown result")

    def fc_start(self):
        self.send_fc_start()
        return self.recv_fc_start()

    def send_fc_start(self):
        self._oprot.writeMessageBegin('fc_start', TMessageType.CALL, self._seqid)
        args = fc_start_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_start(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_start_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_start failed: unknown result")

    def fc_stop(self):
        self.send_fc_stop()
        return self.recv_fc_stop()

    def send_fc_stop(self):
        self._oprot.writeMessageBegin('fc_stop', TMessageType.CALL, self._seqid)
        args = fc_stop_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_stop failed: unknown result")

    def fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        """
        Parameters:
         - direction
         - ref_ft
         - damp
         - max_vel
         - number_list
         - tool
         - wobj
         - value

        """
        self.send_fc_config(direction, ref_ft, damp, max_vel, number_list, tool, wobj, value)
        return self.recv_fc_config()

    def send_fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        self._oprot.writeMessageBegin('fc_config', TMessageType.CALL, self._seqid)
        args = fc_config_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.damp = damp
        args.max_vel = max_vel
        args.number_list = number_list
        args.tool = tool
        args.wobj = wobj
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_config failed: unknown result")

    def fc_move(self):
        self.send_fc_move()
        return self.recv_fc_move()

    def send_fc_move(self):
        self._oprot.writeMessageBegin('fc_move', TMessageType.CALL, self._seqid)
        args = fc_move_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_move failed: unknown result")

    def fc_guard_act(self, direction, ref_ft, tool, wobj, type):
        """
        Parameters:
         - direction
         - ref_ft
         - tool
         - wobj
         - type

        """
        self.send_fc_guard_act(direction, ref_ft, tool, wobj, type)
        return self.recv_fc_guard_act()

    def send_fc_guard_act(self, direction, ref_ft, tool, wobj, type):
        self._oprot.writeMessageBegin('fc_guard_act', TMessageType.CALL, self._seqid)
        args = fc_guard_act_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.tool = tool
        args.wobj = wobj
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_guard_act(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_guard_act_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_guard_act failed: unknown result")

    def fc_guard_deact(self):
        self.send_fc_guard_deact()
        return self.recv_fc_guard_deact()

    def send_fc_guard_deact(self):
        self._oprot.writeMessageBegin('fc_guard_deact', TMessageType.CALL, self._seqid)
        args = fc_guard_deact_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_guard_deact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_guard_deact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_guard_deact failed: unknown result")

    def fc_force_set_value(self, direction, ref_ft):
        """
        Parameters:
         - direction
         - ref_ft

        """
        self.send_fc_force_set_value(direction, ref_ft)
        return self.recv_fc_force_set_value()

    def send_fc_force_set_value(self, direction, ref_ft):
        self._oprot.writeMessageBegin('fc_force_set_value', TMessageType.CALL, self._seqid)
        args = fc_force_set_value_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_force_set_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_force_set_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_force_set_value failed: unknown result")

    def fc_wait_pos(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_pos(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_pos()

    def send_fc_wait_pos(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_pos', TMessageType.CALL, self._seqid)
        args = fc_wait_pos_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_pos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_pos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_pos failed: unknown result")

    def fc_wait_vel(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_vel(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_vel()

    def send_fc_wait_vel(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_vel', TMessageType.CALL, self._seqid)
        args = fc_wait_vel_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_vel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_vel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_vel failed: unknown result")

    def fc_wait_ft(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_ft(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_ft()

    def send_fc_wait_ft(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_ft', TMessageType.CALL, self._seqid)
        args = fc_wait_ft_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_ft(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_ft_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_ft failed: unknown result")

    def fc_wait_logic(self, value):
        """
        Parameters:
         - value

        """
        self.send_fc_wait_logic(value)
        return self.recv_fc_wait_logic()

    def send_fc_wait_logic(self, value):
        self._oprot.writeMessageBegin('fc_wait_logic', TMessageType.CALL, self._seqid)
        args = fc_wait_logic_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_logic(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_logic_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_logic failed: unknown result")

    def fc_get_ft(self):
        self.send_fc_get_ft()
        return self.recv_fc_get_ft()

    def send_fc_get_ft(self):
        self._oprot.writeMessageBegin('fc_get_ft', TMessageType.CALL, self._seqid)
        args = fc_get_ft_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_get_ft(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_get_ft_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_get_ft failed: unknown result")

    def fc_mode_is_active(self):
        self.send_fc_mode_is_active()
        return self.recv_fc_mode_is_active()

    def send_fc_mode_is_active(self):
        self._oprot.writeMessageBegin('fc_mode_is_active', TMessageType.CALL, self._seqid)
        args = fc_mode_is_active_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_mode_is_active(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_mode_is_active_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_mode_is_active failed: unknown result")

    def start_realtime_mode(self):
        self.send_start_realtime_mode()
        return self.recv_start_realtime_mode()

    def send_start_realtime_mode(self):
        self._oprot.writeMessageBegin('start_realtime_mode', TMessageType.CALL, self._seqid)
        args = start_realtime_mode_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_realtime_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_realtime_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_realtime_mode failed: unknown result")

    def end_realtime_mode(self):
        self.send_end_realtime_mode()
        return self.recv_end_realtime_mode()

    def send_end_realtime_mode(self):
        self._oprot.writeMessageBegin('end_realtime_mode', TMessageType.CALL, self._seqid)
        args = end_realtime_mode_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_realtime_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_realtime_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "end_realtime_mode failed: unknown result")

    def enable_speed_optimization(self, block):
        """
        Parameters:
         - block

        """
        self.send_enable_speed_optimization(block)
        return self.recv_enable_speed_optimization()

    def send_enable_speed_optimization(self, block):
        self._oprot.writeMessageBegin('enable_speed_optimization', TMessageType.CALL, self._seqid)
        args = enable_speed_optimization_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_speed_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_speed_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_speed_optimization failed: unknown result")

    def disable_speed_optimization(self, block):
        """
        Parameters:
         - block

        """
        self.send_disable_speed_optimization(block)
        return self.recv_disable_speed_optimization()

    def send_disable_speed_optimization(self, block):
        self._oprot.writeMessageBegin('disable_speed_optimization', TMessageType.CALL, self._seqid)
        args = disable_speed_optimization_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_speed_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_speed_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_speed_optimization failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["power_on"] = Processor.process_power_on
        self._processMap["power_off"] = Processor.process_power_off
        self._processMap["enable"] = Processor.process_enable
        self._processMap["disable"] = Processor.process_disable
        self._processMap["shutdown"] = Processor.process_shutdown
        self._processMap["stop"] = Processor.process_stop
        self._processMap["pause"] = Processor.process_pause
        self._processMap["resume"] = Processor.process_resume
        self._processMap["run_program"] = Processor.process_run_program
        self._processMap["set_tool_data"] = Processor.process_set_tool_data
        self._processMap["get_tool_load"] = Processor.process_get_tool_load
        self._processMap["get_tcp_offset"] = Processor.process_get_tcp_offset
        self._processMap["set_wobj"] = Processor.process_set_wobj
        self._processMap["set_wobj_offset"] = Processor.process_set_wobj_offset
        self._processMap["get_wobj"] = Processor.process_get_wobj
        self._processMap["cal_fkine"] = Processor.process_cal_fkine
        self._processMap["cal_ikine"] = Processor.process_cal_ikine
        self._processMap["set_standard_digital_out"] = Processor.process_set_standard_digital_out
        self._processMap["set_tool_digital_out"] = Processor.process_set_tool_digital_out
        self._processMap["get_standard_digital_in"] = Processor.process_get_standard_digital_in
        self._processMap["get_tool_digital_in"] = Processor.process_get_tool_digital_in
        self._processMap["get_config_digital_in"] = Processor.process_get_config_digital_in
        self._processMap["get_standard_analog_voltage_in"] = Processor.process_get_standard_analog_voltage_in
        self._processMap["get_tool_analog_voltage_in"] = Processor.process_get_tool_analog_voltage_in
        self._processMap["get_standard_analog_current_in"] = Processor.process_get_standard_analog_current_in
        self._processMap["read_raw_data_485"] = Processor.process_read_raw_data_485
        self._processMap["read_raw_data_485_ht"] = Processor.process_read_raw_data_485_ht
        self._processMap["read_raw_data_485_h"] = Processor.process_read_raw_data_485_h
        self._processMap["write_raw_data_485"] = Processor.process_write_raw_data_485
        self._processMap["write_raw_data_485_h"] = Processor.process_write_raw_data_485_h
        self._processMap["write_raw_data_485_ht"] = Processor.process_write_raw_data_485_ht
        self._processMap["tool_read_raw_data_485"] = Processor.process_tool_read_raw_data_485
        self._processMap["tool_read_raw_data_485_h"] = Processor.process_tool_read_raw_data_485_h
        self._processMap["tool_read_raw_data_485_ht"] = Processor.process_tool_read_raw_data_485_ht
        self._processMap["tool_write_raw_data_485"] = Processor.process_tool_write_raw_data_485
        self._processMap["tool_write_raw_data_485_h"] = Processor.process_tool_write_raw_data_485_h
        self._processMap["tool_write_raw_data_485_ht"] = Processor.process_tool_write_raw_data_485_ht
        self._processMap["read_raw_data_can"] = Processor.process_read_raw_data_can
        self._processMap["write_raw_data_can"] = Processor.process_write_raw_data_can
        self._processMap["get_function_digital_in"] = Processor.process_get_function_digital_in
        self._processMap["get_function_digital_out"] = Processor.process_get_function_digital_out
        self._processMap["read_bool_reg"] = Processor.process_read_bool_reg
        self._processMap["read_word_reg"] = Processor.process_read_word_reg
        self._processMap["read_float_reg"] = Processor.process_read_float_reg
        self._processMap["write_bool_reg"] = Processor.process_write_bool_reg
        self._processMap["write_word_reg"] = Processor.process_write_word_reg
        self._processMap["write_float_reg"] = Processor.process_write_float_reg
        self._processMap["movej"] = Processor.process_movej
        self._processMap["movej_pose"] = Processor.process_movej_pose
        self._processMap["movej2"] = Processor.process_movej2
        self._processMap["movej_pose2"] = Processor.process_movej_pose2
        self._processMap["movel"] = Processor.process_movel
        self._processMap["movec"] = Processor.process_movec
        self._processMap["move_circle"] = Processor.process_move_circle
        self._processMap["tcp_move"] = Processor.process_tcp_move
        self._processMap["tcp_move_2p"] = Processor.process_tcp_move_2p
        self._processMap["spline"] = Processor.process_spline
        self._processMap["speedj"] = Processor.process_speedj
        self._processMap["speedl"] = Processor.process_speedl
        self._processMap["speed_stop"] = Processor.process_speed_stop
        self._processMap["servoj"] = Processor.process_servoj
        self._processMap["servoj_pose"] = Processor.process_servoj_pose
        self._processMap["servol"] = Processor.process_servol
        self._processMap["teach_mode"] = Processor.process_teach_mode
        self._processMap["end_teach_mode"] = Processor.process_end_teach_mode
        self._processMap["modbus_add_signal"] = Processor.process_modbus_add_signal
        self._processMap["modbus_delete_signal"] = Processor.process_modbus_delete_signal
        self._processMap["modbus_read"] = Processor.process_modbus_read
        self._processMap["modbus_write"] = Processor.process_modbus_write
        self._processMap["modbus_set_frequency"] = Processor.process_modbus_set_frequency
        self._processMap["get_last_error"] = Processor.process_get_last_error
        self._processMap["get_noneblock_taskstate"] = Processor.process_get_noneblock_taskstate
        self._processMap["log_info"] = Processor.process_log_info
        self._processMap["log_error"] = Processor.process_log_error
        self._processMap["simulation"] = Processor.process_simulation
        self._processMap["speed"] = Processor.process_speed
        self._processMap["get_robot_state"] = Processor.process_get_robot_state
        self._processMap["get_flange_pose"] = Processor.process_get_flange_pose
        self._processMap["get_flange_speed"] = Processor.process_get_flange_speed
        self._processMap["get_flange_acceleration"] = Processor.process_get_flange_acceleration
        self._processMap["get_tcp_pose"] = Processor.process_get_tcp_pose
        self._processMap["get_tcp_speed"] = Processor.process_get_tcp_speed
        self._processMap["get_tcp_acceleration"] = Processor.process_get_tcp_acceleration
        self._processMap["get_tcp_force"] = Processor.process_get_tcp_force
        self._processMap["get_actual_joints_position"] = Processor.process_get_actual_joints_position
        self._processMap["get_target_joints_position"] = Processor.process_get_target_joints_position
        self._processMap["get_actual_joints_speed"] = Processor.process_get_actual_joints_speed
        self._processMap["get_target_joints_speed"] = Processor.process_get_target_joints_speed
        self._processMap["get_actual_joints_acceleration"] = Processor.process_get_actual_joints_acceleration
        self._processMap["get_target_joints_acceleration"] = Processor.process_get_target_joints_acceleration
        self._processMap["get_actual_joints_torque"] = Processor.process_get_actual_joints_torque
        self._processMap["get_target_joints_torque"] = Processor.process_get_target_joints_torque
        self._processMap["stop_record_track"] = Processor.process_stop_record_track
        self._processMap["start_record_track"] = Processor.process_start_record_track
        self._processMap["collision_detect"] = Processor.process_collision_detect
        self._processMap["replay"] = Processor.process_replay
        self._processMap["set_load_data"] = Processor.process_set_load_data
        self._processMap["fc_start"] = Processor.process_fc_start
        self._processMap["fc_stop"] = Processor.process_fc_stop
        self._processMap["fc_config"] = Processor.process_fc_config
        self._processMap["fc_move"] = Processor.process_fc_move
        self._processMap["fc_guard_act"] = Processor.process_fc_guard_act
        self._processMap["fc_guard_deact"] = Processor.process_fc_guard_deact
        self._processMap["fc_force_set_value"] = Processor.process_fc_force_set_value
        self._processMap["fc_wait_pos"] = Processor.process_fc_wait_pos
        self._processMap["fc_wait_vel"] = Processor.process_fc_wait_vel
        self._processMap["fc_wait_ft"] = Processor.process_fc_wait_ft
        self._processMap["fc_wait_logic"] = Processor.process_fc_wait_logic
        self._processMap["fc_get_ft"] = Processor.process_fc_get_ft
        self._processMap["fc_mode_is_active"] = Processor.process_fc_mode_is_active
        self._processMap["start_realtime_mode"] = Processor.process_start_realtime_mode
        self._processMap["end_realtime_mode"] = Processor.process_end_realtime_mode
        self._processMap["enable_speed_optimization"] = Processor.process_enable_speed_optimization
        self._processMap["disable_speed_optimization"] = Processor.process_disable_speed_optimization
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_power_on(self, seqid, iprot, oprot):
        args = power_on_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = power_on_result()
        try:
            result.success = self._handler.power_on(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("power_on", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_power_off(self, seqid, iprot, oprot):
        args = power_off_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = power_off_result()
        try:
            result.success = self._handler.power_off(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("power_off", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable(self, seqid, iprot, oprot):
        args = enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_result()
        try:
            result.success = self._handler.enable(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable(self, seqid, iprot, oprot):
        args = disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_result()
        try:
            result.success = self._handler.disable(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown(self, seqid, iprot, oprot):
        args = shutdown_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shutdown_result()
        try:
            result.success = self._handler.shutdown(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shutdown", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop(self, seqid, iprot, oprot):
        args = stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_result()
        try:
            result.success = self._handler.stop(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pause(self, seqid, iprot, oprot):
        args = pause_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pause_result()
        try:
            result.success = self._handler.pause(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pause", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resume(self, seqid, iprot, oprot):
        args = resume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resume_result()
        try:
            result.success = self._handler.resume(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_run_program(self, seqid, iprot, oprot):
        args = run_program_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = run_program_result()
        try:
            result.success = self._handler.run_program(args.name, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("run_program", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_tool_data(self, seqid, iprot, oprot):
        args = set_tool_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_tool_data_result()
        try:
            result.success = self._handler.set_tool_data(args.name, args.tool_offset, args.payload, args.inertia_tensor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_tool_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_load(self, seqid, iprot, oprot):
        args = get_tool_load_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_load_result()
        try:
            result.success = self._handler.get_tool_load()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_load", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_offset(self, seqid, iprot, oprot):
        args = get_tcp_offset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_offset_result()
        try:
            result.success = self._handler.get_tcp_offset()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_offset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_wobj(self, seqid, iprot, oprot):
        args = set_wobj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_wobj_result()
        try:
            result.success = self._handler.set_wobj(args.name, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_wobj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_wobj_offset(self, seqid, iprot, oprot):
        args = set_wobj_offset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_wobj_offset_result()
        try:
            result.success = self._handler.set_wobj_offset(args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_wobj_offset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_wobj(self, seqid, iprot, oprot):
        args = get_wobj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_wobj_result()
        try:
            result.success = self._handler.get_wobj()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_wobj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cal_fkine(self, seqid, iprot, oprot):
        args = cal_fkine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cal_fkine_result()
        try:
            result.success = self._handler.cal_fkine(args.joints_position, args.tool, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cal_fkine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cal_ikine(self, seqid, iprot, oprot):
        args = cal_ikine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cal_ikine_result()
        try:
            result.success = self._handler.cal_ikine(args.p, args.q_near, args.tool, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cal_ikine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_standard_digital_out(self, seqid, iprot, oprot):
        args = set_standard_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_standard_digital_out_result()
        try:
            result.success = self._handler.set_standard_digital_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_standard_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_tool_digital_out(self, seqid, iprot, oprot):
        args = set_tool_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_tool_digital_out_result()
        try:
            result.success = self._handler.set_tool_digital_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_tool_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_digital_in(self, seqid, iprot, oprot):
        args = get_standard_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_digital_in_result()
        try:
            result.success = self._handler.get_standard_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_digital_in(self, seqid, iprot, oprot):
        args = get_tool_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_digital_in_result()
        try:
            result.success = self._handler.get_tool_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_config_digital_in(self, seqid, iprot, oprot):
        args = get_config_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_config_digital_in_result()
        try:
            result.success = self._handler.get_config_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_config_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_analog_voltage_in(self, seqid, iprot, oprot):
        args = get_standard_analog_voltage_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_analog_voltage_in_result()
        try:
            result.success = self._handler.get_standard_analog_voltage_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_analog_voltage_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_analog_voltage_in(self, seqid, iprot, oprot):
        args = get_tool_analog_voltage_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_analog_voltage_in_result()
        try:
            result.success = self._handler.get_tool_analog_voltage_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_analog_voltage_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_analog_current_in(self, seqid, iprot, oprot):
        args = get_standard_analog_current_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_analog_current_in_result()
        try:
            result.success = self._handler.get_standard_analog_current_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_analog_current_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485(self, seqid, iprot, oprot):
        args = read_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_result()
        try:
            result.success = self._handler.read_raw_data_485(args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485_ht(self, seqid, iprot, oprot):
        args = read_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_ht_result()
        try:
            result.success = self._handler.read_raw_data_485_ht(args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485_h(self, seqid, iprot, oprot):
        args = read_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_h_result()
        try:
            result.success = self._handler.read_raw_data_485_h(args.head, args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485(self, seqid, iprot, oprot):
        args = write_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_result()
        try:
            result.success = self._handler.write_raw_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485_h(self, seqid, iprot, oprot):
        args = write_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_h_result()
        try:
            result.success = self._handler.write_raw_data_485_h(args.data, args.head)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485_ht(self, seqid, iprot, oprot):
        args = write_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_ht_result()
        try:
            result.success = self._handler.write_raw_data_485_ht(args.data, args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_result()
        try:
            result.success = self._handler.tool_read_raw_data_485(args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485_h(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_h_result()
        try:
            result.success = self._handler.tool_read_raw_data_485_h(args.head, args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485_ht(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_ht_result()
        try:
            result.success = self._handler.tool_read_raw_data_485_ht(args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_result()
        try:
            result.success = self._handler.tool_write_raw_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485_h(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_h_result()
        try:
            result.success = self._handler.tool_write_raw_data_485_h(args.data, args.head)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485_ht(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_ht_result()
        try:
            result.success = self._handler.tool_write_raw_data_485_ht(args.data, args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_can(self, seqid, iprot, oprot):
        args = read_raw_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_can_result()
        try:
            result.success = self._handler.read_raw_data_can()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_can(self, seqid, iprot, oprot):
        args = write_raw_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_can_result()
        try:
            result.success = self._handler.write_raw_data_can(args.id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_digital_in(self, seqid, iprot, oprot):
        args = get_function_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_digital_in_result()
        try:
            result.success = self._handler.get_function_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_digital_out(self, seqid, iprot, oprot):
        args = get_function_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_digital_out_result()
        try:
            result.success = self._handler.get_function_digital_out(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_bool_reg(self, seqid, iprot, oprot):
        args = read_bool_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_bool_reg_result()
        try:
            result.success = self._handler.read_bool_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_bool_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_word_reg(self, seqid, iprot, oprot):
        args = read_word_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_word_reg_result()
        try:
            result.success = self._handler.read_word_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_word_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_float_reg(self, seqid, iprot, oprot):
        args = read_float_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_float_reg_result()
        try:
            result.success = self._handler.read_float_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_float_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_bool_reg(self, seqid, iprot, oprot):
        args = write_bool_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_bool_reg_result()
        try:
            result.success = self._handler.write_bool_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_bool_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_word_reg(self, seqid, iprot, oprot):
        args = write_word_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_word_reg_result()
        try:
            result.success = self._handler.write_word_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_word_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_float_reg(self, seqid, iprot, oprot):
        args = write_float_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_float_reg_result()
        try:
            result.success = self._handler.write_float_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_float_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej(self, seqid, iprot, oprot):
        args = movej_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_result()
        try:
            result.success = self._handler.movej(args.joints_list, args.v, args.a, args.r, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej_pose(self, seqid, iprot, oprot):
        args = movej_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_pose_result()
        try:
            result.success = self._handler.movej_pose(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej2(self, seqid, iprot, oprot):
        args = movej2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej2_result()
        try:
            result.success = self._handler.movej2(args.joints_list, args.v, args.a, args.r, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej_pose2(self, seqid, iprot, oprot):
        args = movej_pose2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_pose2_result()
        try:
            result.success = self._handler.movej_pose2(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej_pose2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movel(self, seqid, iprot, oprot):
        args = movel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movel_result()
        try:
            result.success = self._handler.movel(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movec(self, seqid, iprot, oprot):
        args = movec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movec_result()
        try:
            result.success = self._handler.movec(args.p1, args.p2, args.v, args.a, args.r, args.mode, args.q_near, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_circle(self, seqid, iprot, oprot):
        args = move_circle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_circle_result()
        try:
            result.success = self._handler.move_circle(args.p1, args.p2, args.v, args.a, args.r, args.mode, args.q_near, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_circle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcp_move(self, seqid, iprot, oprot):
        args = tcp_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcp_move_result()
        try:
            result.success = self._handler.tcp_move(args.pose_offset, args.v, args.a, args.r, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcp_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcp_move_2p(self, seqid, iprot, oprot):
        args = tcp_move_2p_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcp_move_2p_result()
        try:
            result.success = self._handler.tcp_move_2p(args.p1, args.p2, args.v, args.a, args.r, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcp_move_2p", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spline(self, seqid, iprot, oprot):
        args = spline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spline_result()
        try:
            result.success = self._handler.spline(args.pose_list, args.v, args.a, args.tool, args.wobj, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speedj(self, seqid, iprot, oprot):
        args = speedj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speedj_result()
        try:
            result.success = self._handler.speedj(args.joints_list, args.a, args.time, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speedj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speedl(self, seqid, iprot, oprot):
        args = speedl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speedl_result()
        try:
            result.success = self._handler.speedl(args.pose_list, args.a, args.time, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speedl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speed_stop(self, seqid, iprot, oprot):
        args = speed_stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speed_stop_result()
        try:
            result.success = self._handler.speed_stop(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speed_stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servoj(self, seqid, iprot, oprot):
        args = servoj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servoj_result()
        try:
            result.success = self._handler.servoj(args.joints_list, args.v, args.a, args.kp, args.kd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servoj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servoj_pose(self, seqid, iprot, oprot):
        args = servoj_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servoj_pose_result()
        try:
            result.success = self._handler.servoj_pose(args.pose_list, args.v, args.a, args.q_near, args.tool, args.wobj, args.kp, args.kd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servoj_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servol(self, seqid, iprot, oprot):
        args = servol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servol_result()
        try:
            result.success = self._handler.servol(args.pose_list, args.v, args.a, args.q_near, args.tool, args.wobj, args.kp, args.kd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_teach_mode(self, seqid, iprot, oprot):
        args = teach_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = teach_mode_result()
        try:
            result.success = self._handler.teach_mode(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("teach_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_end_teach_mode(self, seqid, iprot, oprot):
        args = end_teach_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_teach_mode_result()
        try:
            result.success = self._handler.end_teach_mode(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_teach_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_add_signal(self, seqid, iprot, oprot):
        args = modbus_add_signal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_add_signal_result()
        try:
            result.success = self._handler.modbus_add_signal(args.ip, args.slave_number, args.signal_address, args.signal_type, args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_add_signal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_delete_signal(self, seqid, iprot, oprot):
        args = modbus_delete_signal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_delete_signal_result()
        try:
            result.success = self._handler.modbus_delete_signal(args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_delete_signal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_read(self, seqid, iprot, oprot):
        args = modbus_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_read_result()
        try:
            result.success = self._handler.modbus_read(args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_write(self, seqid, iprot, oprot):
        args = modbus_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_write_result()
        try:
            result.success = self._handler.modbus_write(args.signal_name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_set_frequency(self, seqid, iprot, oprot):
        args = modbus_set_frequency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_set_frequency_result()
        try:
            self._handler.modbus_set_frequency(args.signal_name, args.frequence)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_set_frequency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_last_error(self, seqid, iprot, oprot):
        args = get_last_error_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_last_error_result()
        try:
            result.success = self._handler.get_last_error()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_last_error", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_noneblock_taskstate(self, seqid, iprot, oprot):
        args = get_noneblock_taskstate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_noneblock_taskstate_result()
        try:
            result.success = self._handler.get_noneblock_taskstate(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_noneblock_taskstate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_log_info(self, seqid, iprot, oprot):
        args = log_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = log_info_result()
        try:
            self._handler.log_info(args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("log_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_log_error(self, seqid, iprot, oprot):
        args = log_error_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = log_error_result()
        try:
            self._handler.log_error(args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("log_error", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simulation(self, seqid, iprot, oprot):
        args = simulation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simulation_result()
        try:
            result.success = self._handler.simulation(args.sim, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simulation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speed(self, seqid, iprot, oprot):
        args = speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speed_result()
        try:
            result.success = self._handler.speed(args.val)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_robot_state(self, seqid, iprot, oprot):
        args = get_robot_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_robot_state_result()
        try:
            result.success = self._handler.get_robot_state()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_robot_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_pose(self, seqid, iprot, oprot):
        args = get_flange_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_pose_result()
        try:
            result.success = self._handler.get_flange_pose()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_speed(self, seqid, iprot, oprot):
        args = get_flange_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_speed_result()
        try:
            result.success = self._handler.get_flange_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_acceleration(self, seqid, iprot, oprot):
        args = get_flange_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_acceleration_result()
        try:
            result.success = self._handler.get_flange_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_pose(self, seqid, iprot, oprot):
        args = get_tcp_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_pose_result()
        try:
            result.success = self._handler.get_tcp_pose()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_speed(self, seqid, iprot, oprot):
        args = get_tcp_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_speed_result()
        try:
            result.success = self._handler.get_tcp_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_acceleration(self, seqid, iprot, oprot):
        args = get_tcp_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_acceleration_result()
        try:
            result.success = self._handler.get_tcp_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_force(self, seqid, iprot, oprot):
        args = get_tcp_force_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_force_result()
        try:
            result.success = self._handler.get_tcp_force()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_force", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_position(self, seqid, iprot, oprot):
        args = get_actual_joints_position_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_position_result()
        try:
            result.success = self._handler.get_actual_joints_position()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_position", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_position(self, seqid, iprot, oprot):
        args = get_target_joints_position_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_position_result()
        try:
            result.success = self._handler.get_target_joints_position()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_position", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_speed(self, seqid, iprot, oprot):
        args = get_actual_joints_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_speed_result()
        try:
            result.success = self._handler.get_actual_joints_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_speed(self, seqid, iprot, oprot):
        args = get_target_joints_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_speed_result()
        try:
            result.success = self._handler.get_target_joints_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_acceleration(self, seqid, iprot, oprot):
        args = get_actual_joints_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_acceleration_result()
        try:
            result.success = self._handler.get_actual_joints_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_acceleration(self, seqid, iprot, oprot):
        args = get_target_joints_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_acceleration_result()
        try:
            result.success = self._handler.get_target_joints_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_torque(self, seqid, iprot, oprot):
        args = get_actual_joints_torque_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_torque_result()
        try:
            result.success = self._handler.get_actual_joints_torque()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_torque", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_torque(self, seqid, iprot, oprot):
        args = get_target_joints_torque_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_torque_result()
        try:
            result.success = self._handler.get_target_joints_torque()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_torque", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_record_track(self, seqid, iprot, oprot):
        args = stop_record_track_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_record_track_result()
        try:
            result.success = self._handler.stop_record_track()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_record_track", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_record_track(self, seqid, iprot, oprot):
        args = start_record_track_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_record_track_result()
        try:
            result.success = self._handler.start_record_track(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_record_track", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_collision_detect(self, seqid, iprot, oprot):
        args = collision_detect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = collision_detect_result()
        try:
            result.success = self._handler.collision_detect(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("collision_detect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_replay(self, seqid, iprot, oprot):
        args = replay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = replay_result()
        try:
            result.success = self._handler.replay(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("replay", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_load_data(self, seqid, iprot, oprot):
        args = set_load_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_load_data_result()
        try:
            result.success = self._handler.set_load_data(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_load_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_start(self, seqid, iprot, oprot):
        args = fc_start_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_start_result()
        try:
            result.success = self._handler.fc_start()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_start", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_stop(self, seqid, iprot, oprot):
        args = fc_stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_stop_result()
        try:
            result.success = self._handler.fc_stop()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_config(self, seqid, iprot, oprot):
        args = fc_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_config_result()
        try:
            result.success = self._handler.fc_config(args.direction, args.ref_ft, args.damp, args.max_vel, args.number_list, args.tool, args.wobj, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_move(self, seqid, iprot, oprot):
        args = fc_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_move_result()
        try:
            result.success = self._handler.fc_move()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_guard_act(self, seqid, iprot, oprot):
        args = fc_guard_act_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_guard_act_result()
        try:
            result.success = self._handler.fc_guard_act(args.direction, args.ref_ft, args.tool, args.wobj, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_guard_act", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_guard_deact(self, seqid, iprot, oprot):
        args = fc_guard_deact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_guard_deact_result()
        try:
            result.success = self._handler.fc_guard_deact()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_guard_deact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_force_set_value(self, seqid, iprot, oprot):
        args = fc_force_set_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_force_set_value_result()
        try:
            result.success = self._handler.fc_force_set_value(args.direction, args.ref_ft)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_force_set_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_pos(self, seqid, iprot, oprot):
        args = fc_wait_pos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_pos_result()
        try:
            result.success = self._handler.fc_wait_pos(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_pos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_vel(self, seqid, iprot, oprot):
        args = fc_wait_vel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_vel_result()
        try:
            result.success = self._handler.fc_wait_vel(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_vel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_ft(self, seqid, iprot, oprot):
        args = fc_wait_ft_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_ft_result()
        try:
            result.success = self._handler.fc_wait_ft(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_ft", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_logic(self, seqid, iprot, oprot):
        args = fc_wait_logic_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_logic_result()
        try:
            result.success = self._handler.fc_wait_logic(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_logic", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_get_ft(self, seqid, iprot, oprot):
        args = fc_get_ft_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_get_ft_result()
        try:
            result.success = self._handler.fc_get_ft()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_get_ft", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_mode_is_active(self, seqid, iprot, oprot):
        args = fc_mode_is_active_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_mode_is_active_result()
        try:
            result.success = self._handler.fc_mode_is_active()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_mode_is_active", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_realtime_mode(self, seqid, iprot, oprot):
        args = start_realtime_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_realtime_mode_result()
        try:
            result.success = self._handler.start_realtime_mode()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_realtime_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_end_realtime_mode(self, seqid, iprot, oprot):
        args = end_realtime_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_realtime_mode_result()
        try:
            result.success = self._handler.end_realtime_mode()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_realtime_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_speed_optimization(self, seqid, iprot, oprot):
        args = enable_speed_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_speed_optimization_result()
        try:
            result.success = self._handler.enable_speed_optimization(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_speed_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_speed_optimization(self, seqid, iprot, oprot):
        args = disable_speed_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_speed_optimization_result()
        try:
            result.success = self._handler.disable_speed_optimization(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_speed_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class power_on_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_on_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_on_args)
power_on_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class power_on_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_on_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_on_result)
power_on_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class power_off_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_off_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_off_args)
power_off_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class power_off_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_off_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_off_result)
power_off_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_args)
enable_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class enable_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_result)
enable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_args)
disable_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class disable_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_result)
disable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class shutdown_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_args)
shutdown_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class shutdown_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_result)
shutdown_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class stop_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_args)
stop_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_result)
stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class pause_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pause_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pause_args)
pause_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class pause_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pause_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pause_result)
pause_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class resume_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_args)
resume_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class resume_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_result)
resume_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class run_program_args(object):
    """
    Attributes:
     - name
     - block

    """


    def __init__(self, name=None, block=None,):
        self.name = name
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_program_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_program_args)
run_program_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class run_program_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_program_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_program_result)
run_program_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_tool_data_args(object):
    """
    Attributes:
     - name
     - tool_offset
     - payload
     - inertia_tensor

    """


    def __init__(self, name=None, tool_offset=None, payload=None, inertia_tensor=None,):
        self.name = name
        self.tool_offset = tool_offset
        self.payload = payload
        self.inertia_tensor = inertia_tensor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tool_offset = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readDouble()
                        self.tool_offset.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.payload = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readDouble()
                        self.payload.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.inertia_tensor = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readDouble()
                        self.inertia_tensor.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_data_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.tool_offset is not None:
            oprot.writeFieldBegin('tool_offset', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool_offset))
            for iter18 in self.tool_offset:
                oprot.writeDouble(iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.payload))
            for iter19 in self.payload:
                oprot.writeDouble(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inertia_tensor is not None:
            oprot.writeFieldBegin('inertia_tensor', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.inertia_tensor))
            for iter20 in self.inertia_tensor:
                oprot.writeDouble(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_data_args)
set_tool_data_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tool_offset', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'payload', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'inertia_tensor', (TType.DOUBLE, None, False), None, ),  # 4
)


class set_tool_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_data_result)
set_tool_data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_tool_load_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_load_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_load_args)
get_tool_load_args.thrift_spec = (
)


class get_tool_load_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readDouble()
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_load_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter27 in self.success:
                oprot.writeDouble(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_load_result)
get_tool_load_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_offset_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_offset_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_offset_args)
get_tcp_offset_args.thrift_spec = (
)


class get_tcp_offset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readDouble()
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_offset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter34 in self.success:
                oprot.writeDouble(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_offset_result)
get_tcp_offset_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class set_wobj_args(object):
    """
    Attributes:
     - name
     - wobj

    """


    def __init__(self, name=None, wobj=None,):
        self.name = name
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readDouble()
                        self.wobj.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter41 in self.wobj:
                oprot.writeDouble(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_args)
set_wobj_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 2
)


class set_wobj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_result)
set_wobj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_wobj_offset_args(object):
    """
    Attributes:
     - wobj

    """


    def __init__(self, wobj=None,):
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readDouble()
                        self.wobj.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_offset_args')
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter48 in self.wobj:
                oprot.writeDouble(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_offset_args)
set_wobj_offset_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 1
)


class set_wobj_offset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_offset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_offset_result)
set_wobj_offset_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_wobj_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_wobj_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_wobj_args)
get_wobj_args.thrift_spec = (
)


class get_wobj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readDouble()
                        self.success.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_wobj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter55 in self.success:
                oprot.writeDouble(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_wobj_result)
get_wobj_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class cal_fkine_args(object):
    """
    Attributes:
     - joints_position
     - tool
     - wobj

    """


    def __init__(self, joints_position=None, tool=None, wobj=None,):
        self.joints_position = joints_position
        self.tool = tool
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_position = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = iprot.readDouble()
                        self.joints_position.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tool = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = iprot.readDouble()
                        self.tool.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype71, _size68) = iprot.readListBegin()
                    for _i72 in range(_size68):
                        _elem73 = iprot.readDouble()
                        self.wobj.append(_elem73)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_fkine_args')
        if self.joints_position is not None:
            oprot.writeFieldBegin('joints_position', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_position))
            for iter74 in self.joints_position:
                oprot.writeDouble(iter74)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool))
            for iter75 in self.tool:
                oprot.writeDouble(iter75)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter76 in self.wobj:
                oprot.writeDouble(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_fkine_args)
cal_fkine_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_position', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'tool', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 3
)


class cal_fkine_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readDouble()
                        self.success.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_fkine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter83 in self.success:
                oprot.writeDouble(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_fkine_result)
cal_fkine_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class cal_ikine_args(object):
    """
    Attributes:
     - p
     - q_near
     - tool
     - wobj

    """


    def __init__(self, p=None, q_near=None, tool=None, wobj=None,):
        self.p = p
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readDouble()
                        self.p.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = iprot.readDouble()
                        self.q_near.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tool = []
                    (_etype99, _size96) = iprot.readListBegin()
                    for _i100 in range(_size96):
                        _elem101 = iprot.readDouble()
                        self.tool.append(_elem101)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype105, _size102) = iprot.readListBegin()
                    for _i106 in range(_size102):
                        _elem107 = iprot.readDouble()
                        self.wobj.append(_elem107)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_ikine_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter108 in self.p:
                oprot.writeDouble(iter108)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter109 in self.q_near:
                oprot.writeDouble(iter109)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool))
            for iter110 in self.tool:
                oprot.writeDouble(iter110)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter111 in self.wobj:
                oprot.writeDouble(iter111)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_ikine_args)
cal_ikine_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'tool', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 4
)


class cal_ikine_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = iprot.readDouble()
                        self.success.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_ikine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter118 in self.success:
                oprot.writeDouble(iter118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_ikine_result)
cal_ikine_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class set_standard_digital_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_digital_out_args)
set_standard_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_standard_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_digital_out_result)
set_standard_digital_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_tool_digital_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_digital_out_args)
set_tool_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_tool_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_digital_out_result)
set_tool_digital_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_standard_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_in_args)
get_standard_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_in_result)
get_standard_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_tool_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_in_args)
get_tool_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_tool_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_in_result)
get_tool_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_config_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_digital_in_args)
get_config_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_config_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_digital_in_result)
get_config_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_standard_analog_voltage_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_voltage_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_voltage_in_args)
get_standard_analog_voltage_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_analog_voltage_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_voltage_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_voltage_in_result)
get_standard_analog_voltage_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class get_tool_analog_voltage_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_analog_voltage_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_analog_voltage_in_args)
get_tool_analog_voltage_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_tool_analog_voltage_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_analog_voltage_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_analog_voltage_in_result)
get_tool_analog_voltage_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class get_standard_analog_current_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_current_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_current_in_args)
get_standard_analog_current_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_analog_current_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_current_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_current_in_result)
get_standard_analog_current_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class read_raw_data_485_args(object):
    """
    Attributes:
     - len

    """


    def __init__(self, len=None,):
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_args')
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 1)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_args)
read_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'len', None, None, ),  # 1
)


class read_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = iprot.readByte()
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter125 in self.success:
                oprot.writeByte(iter125)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_result)
read_raw_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_485_ht_args(object):
    """
    Attributes:
     - head
     - tail

    """


    def __init__(self, head=None, tail=None,):
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = iprot.readByte()
                        self.head.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readByte()
                        self.tail.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_ht_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter138 in self.head:
                oprot.writeByte(iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter139 in self.tail:
                oprot.writeByte(iter139)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_ht_args)
read_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 2
)


class read_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = iprot.readByte()
                        self.success.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter146 in self.success:
                oprot.writeByte(iter146)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_ht_result)
read_raw_data_485_ht_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_485_h_args(object):
    """
    Attributes:
     - head
     - len

    """


    def __init__(self, head=None, len=None,):
        self.head = head
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readByte()
                        self.head.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_h_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter153 in self.head:
                oprot.writeByte(iter153)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 2)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_h_args)
read_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.I32, 'len', None, None, ),  # 2
)


class read_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype157, _size154) = iprot.readListBegin()
                    for _i158 in range(_size154):
                        _elem159 = iprot.readByte()
                        self.success.append(_elem159)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter160 in self.success:
                oprot.writeByte(iter160)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_h_result)
read_raw_data_485_h_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class write_raw_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = iprot.readByte()
                        self.data.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter167 in self.data:
                oprot.writeByte(iter167)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_args)
write_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class write_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_result)
write_raw_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_485_h_args(object):
    """
    Attributes:
     - data
     - head

    """


    def __init__(self, data=None, head=None,):
        self.data = data
        self.head = head

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = iprot.readByte()
                        self.data.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = iprot.readByte()
                        self.head.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_h_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter180 in self.data:
                oprot.writeByte(iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter181 in self.head:
                oprot.writeByte(iter181)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_h_args)
write_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
)


class write_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_h_result)
write_raw_data_485_h_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_485_ht_args(object):
    """
    Attributes:
     - data
     - head
     - tail

    """


    def __init__(self, data=None, head=None, tail=None,):
        self.data = data
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype185, _size182) = iprot.readListBegin()
                    for _i186 in range(_size182):
                        _elem187 = iprot.readByte()
                        self.data.append(_elem187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = iprot.readByte()
                        self.head.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype197, _size194) = iprot.readListBegin()
                    for _i198 in range(_size194):
                        _elem199 = iprot.readByte()
                        self.tail.append(_elem199)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_ht_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter200 in self.data:
                oprot.writeByte(iter200)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter201 in self.head:
                oprot.writeByte(iter201)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter202 in self.tail:
                oprot.writeByte(iter202)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_ht_args)
write_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
    (3, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 3
)


class write_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_ht_result)
write_raw_data_485_ht_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_read_raw_data_485_args(object):
    """
    Attributes:
     - len

    """


    def __init__(self, len=None,):
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_args')
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 1)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_args)
tool_read_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'len', None, None, ),  # 1
)


class tool_read_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = iprot.readByte()
                        self.success.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter209 in self.success:
                oprot.writeByte(iter209)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_result)
tool_read_raw_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_read_raw_data_485_h_args(object):
    """
    Attributes:
     - head
     - len

    """


    def __init__(self, head=None, len=None,):
        self.head = head
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = iprot.readByte()
                        self.head.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_h_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter216 in self.head:
                oprot.writeByte(iter216)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 2)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_h_args)
tool_read_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.I32, 'len', None, None, ),  # 2
)


class tool_read_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = iprot.readByte()
                        self.success.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter223 in self.success:
                oprot.writeByte(iter223)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_h_result)
tool_read_raw_data_485_h_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_read_raw_data_485_ht_args(object):
    """
    Attributes:
     - head
     - tail

    """


    def __init__(self, head=None, tail=None,):
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype227, _size224) = iprot.readListBegin()
                    for _i228 in range(_size224):
                        _elem229 = iprot.readByte()
                        self.head.append(_elem229)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype233, _size230) = iprot.readListBegin()
                    for _i234 in range(_size230):
                        _elem235 = iprot.readByte()
                        self.tail.append(_elem235)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_ht_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter236 in self.head:
                oprot.writeByte(iter236)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter237 in self.tail:
                oprot.writeByte(iter237)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_ht_args)
tool_read_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 2
)


class tool_read_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = iprot.readByte()
                        self.success.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter244 in self.success:
                oprot.writeByte(iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_ht_result)
tool_read_raw_data_485_ht_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_write_raw_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readByte()
                        self.data.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter251 in self.data:
                oprot.writeByte(iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_args)
tool_write_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class tool_write_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_result)
tool_write_raw_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_write_raw_data_485_h_args(object):
    """
    Attributes:
     - data
     - head

    """


    def __init__(self, data=None, head=None,):
        self.data = data
        self.head = head

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype255, _size252) = iprot.readListBegin()
                    for _i256 in range(_size252):
                        _elem257 = iprot.readByte()
                        self.data.append(_elem257)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = iprot.readByte()
                        self.head.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_h_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter264 in self.data:
                oprot.writeByte(iter264)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter265 in self.head:
                oprot.writeByte(iter265)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_h_args)
tool_write_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
)


class tool_write_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_h_result)
tool_write_raw_data_485_h_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_write_raw_data_485_ht_args(object):
    """
    Attributes:
     - data
     - head
     - tail

    """


    def __init__(self, data=None, head=None, tail=None,):
        self.data = data
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype269, _size266) = iprot.readListBegin()
                    for _i270 in range(_size266):
                        _elem271 = iprot.readByte()
                        self.data.append(_elem271)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype275, _size272) = iprot.readListBegin()
                    for _i276 in range(_size272):
                        _elem277 = iprot.readByte()
                        self.head.append(_elem277)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype281, _size278) = iprot.readListBegin()
                    for _i282 in range(_size278):
                        _elem283 = iprot.readByte()
                        self.tail.append(_elem283)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_ht_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter284 in self.data:
                oprot.writeByte(iter284)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter285 in self.head:
                oprot.writeByte(iter285)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter286 in self.tail:
                oprot.writeByte(iter286)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_ht_args)
tool_write_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
    (3, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 3
)


class tool_write_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_ht_result)
tool_write_raw_data_485_ht_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_raw_data_can_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_can_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_can_args)
read_raw_data_can_args.thrift_spec = (
)


class read_raw_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readByte()
                        self.success.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter293 in self.success:
                oprot.writeByte(iter293)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_can_result)
read_raw_data_can_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class write_raw_data_can_args(object):
    """
    Attributes:
     - id
     - data

    """


    def __init__(self, id=None, data=None,):
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype297, _size294) = iprot.readListBegin()
                    for _i298 in range(_size294):
                        _elem299 = iprot.readByte()
                        self.data.append(_elem299)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_can_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter300 in self.data:
                oprot.writeByte(iter300)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_can_args)
write_raw_data_can_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 2
)


class write_raw_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_can_result)
write_raw_data_can_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_function_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_in_args)
get_function_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_in_result)
get_function_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_function_digital_out_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_out_args)
get_function_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_out_result)
get_function_digital_out_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_bool_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_bool_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_bool_reg_args)
read_bool_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_bool_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_bool_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_bool_reg_result)
read_bool_reg_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_word_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_word_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_word_reg_args)
read_word_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_word_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_word_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_word_reg_result)
read_word_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_float_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_float_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_float_reg_args)
read_float_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_float_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_float_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_float_reg_result)
read_float_reg_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class write_bool_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_bool_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_bool_reg_args)
write_bool_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
)


class write_bool_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_bool_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_bool_reg_result)
write_bool_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class write_word_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_word_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_word_reg_args)
write_word_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class write_word_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_word_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_word_reg_result)
write_word_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class write_float_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_float_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_float_reg_args)
write_float_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
)


class write_float_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_float_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_float_reg_result)
write_float_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - r
     - block
     - op

    """


    def __init__(self, joints_list=None, v=None, a=None, r=None, block=None, op=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype304, _size301) = iprot.readListBegin()
                    for _i305 in range(_size301):
                        _elem306 = iprot.readDouble()
                        self.joints_list.append(_elem306)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter307 in self.joints_list:
                oprot.writeDouble(iter307)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 6)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_args)
movej_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.STRUCT, 'op', [Op, None], None, ),  # 6
)


class movej_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_result)
movej_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej_pose_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype311, _size308) = iprot.readListBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readDouble()
                        self.p.append(_elem313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype317, _size314) = iprot.readListBegin()
                    for _i318 in range(_size314):
                        _elem319 = iprot.readDouble()
                        self.q_near.append(_elem319)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter320 in self.p:
                oprot.writeDouble(iter320)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter321 in self.q_near:
                oprot.writeDouble(iter321)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose_args)
movej_pose_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
)


class movej_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose_result)
movej_pose_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej2_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - r
     - block
     - op

    """


    def __init__(self, joints_list=None, v=None, a=None, r=None, block=None, op=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype325, _size322) = iprot.readListBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readDouble()
                        self.joints_list.append(_elem327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter328 in self.joints_list:
                oprot.writeDouble(iter328)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 6)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_args)
movej2_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.STRUCT, 'op', [Op, None], None, ),  # 6
)


class movej2_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_result)
movej2_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej_pose2_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = iprot.readDouble()
                        self.p.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype338, _size335) = iprot.readListBegin()
                    for _i339 in range(_size335):
                        _elem340 = iprot.readDouble()
                        self.q_near.append(_elem340)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose2_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter341 in self.p:
                oprot.writeDouble(iter341)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter342 in self.q_near:
                oprot.writeDouble(iter342)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose2_args)
movej_pose2_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
)


class movej_pose2_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose2_result)
movej_pose2_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movel_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype346, _size343) = iprot.readListBegin()
                    for _i347 in range(_size343):
                        _elem348 = iprot.readDouble()
                        self.p.append(_elem348)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype352, _size349) = iprot.readListBegin()
                    for _i353 in range(_size349):
                        _elem354 = iprot.readDouble()
                        self.q_near.append(_elem354)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter355 in self.p:
                oprot.writeDouble(iter355)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter356 in self.q_near:
                oprot.writeDouble(iter356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_args)
movel_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
)


class movel_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_result)
movel_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movec_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - mode
     - q_near
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, mode=None, q_near=None, tool=None, wobj=None, block=None, op=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.mode = mode
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = iprot.readDouble()
                        self.p1.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype366, _size363) = iprot.readListBegin()
                    for _i367 in range(_size363):
                        _elem368 = iprot.readDouble()
                        self.p2.append(_elem368)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.mode = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype372, _size369) = iprot.readListBegin()
                    for _i373 in range(_size369):
                        _elem374 = iprot.readDouble()
                        self.q_near.append(_elem374)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter375 in self.p1:
                oprot.writeDouble(iter375)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter376 in self.p2:
                oprot.writeDouble(iter376)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.BOOL, 6)
            oprot.writeBool(self.mode)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter377 in self.q_near:
                oprot.writeDouble(iter377)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 8)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 9)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 10)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 11)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_args)
movec_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.BOOL, 'mode', None, None, ),  # 6
    (7, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 7
    (8, TType.STRING, 'tool', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'wobj', 'UTF8', None, ),  # 9
    (10, TType.BOOL, 'block', None, None, ),  # 10
    (11, TType.STRUCT, 'op', [Op, None], None, ),  # 11
)


class movec_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_result)
movec_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class move_circle_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - mode
     - q_near
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, mode=None, q_near=None, tool=None, wobj=None, block=None, op=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.mode = mode
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = iprot.readDouble()
                        self.p1.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype387, _size384) = iprot.readListBegin()
                    for _i388 in range(_size384):
                        _elem389 = iprot.readDouble()
                        self.p2.append(_elem389)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.mode = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype393, _size390) = iprot.readListBegin()
                    for _i394 in range(_size390):
                        _elem395 = iprot.readDouble()
                        self.q_near.append(_elem395)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter396 in self.p1:
                oprot.writeDouble(iter396)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter397 in self.p2:
                oprot.writeDouble(iter397)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.BOOL, 6)
            oprot.writeBool(self.mode)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter398 in self.q_near:
                oprot.writeDouble(iter398)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 8)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 9)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 10)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 11)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_args)
move_circle_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.BOOL, 'mode', None, None, ),  # 6
    (7, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 7
    (8, TType.STRING, 'tool', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'wobj', 'UTF8', None, ),  # 9
    (10, TType.BOOL, 'block', None, None, ),  # 10
    (11, TType.STRUCT, 'op', [Op, None], None, ),  # 11
)


class move_circle_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_result)
move_circle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tcp_move_args(object):
    """
    Attributes:
     - pose_offset
     - v
     - a
     - r
     - block
     - op

    """


    def __init__(self, pose_offset=None, v=None, a=None, r=None, block=None, op=None,):
        self.pose_offset = pose_offset
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_offset = []
                    (_etype402, _size399) = iprot.readListBegin()
                    for _i403 in range(_size399):
                        _elem404 = iprot.readDouble()
                        self.pose_offset.append(_elem404)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_args')
        if self.pose_offset is not None:
            oprot.writeFieldBegin('pose_offset', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_offset))
            for iter405 in self.pose_offset:
                oprot.writeDouble(iter405)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 6)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_args)
tcp_move_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_offset', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.STRUCT, 'op', [Op, None], None, ),  # 6
)


class tcp_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_result)
tcp_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tcp_move_2p_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - block
     - op

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, block=None, op=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = iprot.readDouble()
                        self.p1.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype415, _size412) = iprot.readListBegin()
                    for _i416 in range(_size412):
                        _elem417 = iprot.readDouble()
                        self.p2.append(_elem417)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_2p_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter418 in self.p1:
                oprot.writeDouble(iter418)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter419 in self.p2:
                oprot.writeDouble(iter419)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_2p_args)
tcp_move_2p_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
)


class tcp_move_2p_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_2p_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_2p_result)
tcp_move_2p_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spline_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - tool
     - wobj
     - block
     - op

    """


    def __init__(self, pose_list=None, v=None, a=None, tool=None, wobj=None, block=None, op=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype423, _size420) = iprot.readListBegin()
                    for _i424 in range(_size420):
                        _elem425 = []
                        (_etype429, _size426) = iprot.readListBegin()
                        for _i430 in range(_size426):
                            _elem431 = iprot.readDouble()
                            _elem425.append(_elem431)
                        iprot.readListEnd()
                        self.pose_list.append(_elem425)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.pose_list))
            for iter432 in self.pose_list:
                oprot.writeListBegin(TType.DOUBLE, len(iter432))
                for iter433 in iter432:
                    oprot.writeDouble(iter433)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 4)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 5)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_args)
spline_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.STRING, 'tool', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'wobj', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
)


class spline_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_result)
spline_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speedj_args(object):
    """
    Attributes:
     - joints_list
     - a
     - time
     - block

    """


    def __init__(self, joints_list=None, a=None, time=None, block=None,):
        self.joints_list = joints_list
        self.a = a
        self.time = time
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype437, _size434) = iprot.readListBegin()
                    for _i438 in range(_size434):
                        _elem439 = iprot.readDouble()
                        self.joints_list.append(_elem439)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedj_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter440 in self.joints_list:
                oprot.writeDouble(iter440)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 2)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I32, 3)
            oprot.writeI32(self.time)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedj_args)
speedj_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'a', None, None, ),  # 2
    (3, TType.I32, 'time', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
)


class speedj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedj_result)
speedj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speedl_args(object):
    """
    Attributes:
     - pose_list
     - a
     - time
     - block

    """


    def __init__(self, pose_list=None, a=None, time=None, block=None,):
        self.pose_list = pose_list
        self.a = a
        self.time = time
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = iprot.readDouble()
                        self.pose_list.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedl_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter447 in self.pose_list:
                oprot.writeDouble(iter447)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 2)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I32, 3)
            oprot.writeI32(self.time)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedl_args)
speedl_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'a', None, None, ),  # 2
    (3, TType.I32, 'time', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
)


class speedl_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedl_result)
speedl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speed_stop_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_stop_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_stop_args)
speed_stop_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class speed_stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_stop_result)
speed_stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servoj_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - kp
     - kd

    """


    def __init__(self, joints_list=None, v=None, a=None, kp=None, kd=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.kp = kp
        self.kd = kd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype451, _size448) = iprot.readListBegin()
                    for _i452 in range(_size448):
                        _elem453 = iprot.readDouble()
                        self.joints_list.append(_elem453)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter454 in self.joints_list:
                oprot.writeDouble(iter454)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 4)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 5)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_args)
servoj_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'kp', None, None, ),  # 4
    (5, TType.DOUBLE, 'kd', None, None, ),  # 5
)


class servoj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_result)
servoj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servoj_pose_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - q_near
     - tool
     - wobj
     - kp
     - kd

    """


    def __init__(self, pose_list=None, v=None, a=None, q_near=None, tool=None, wobj=None, kp=None, kd=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.kp = kp
        self.kd = kd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype458, _size455) = iprot.readListBegin()
                    for _i459 in range(_size455):
                        _elem460 = iprot.readDouble()
                        self.pose_list.append(_elem460)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype464, _size461) = iprot.readListBegin()
                    for _i465 in range(_size461):
                        _elem466 = iprot.readDouble()
                        self.q_near.append(_elem466)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_pose_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter467 in self.pose_list:
                oprot.writeDouble(iter467)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter468 in self.q_near:
                oprot.writeDouble(iter468)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 5)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 6)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 7)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 8)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_pose_args)
servoj_pose_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRING, 'tool', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'wobj', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'kp', None, None, ),  # 7
    (8, TType.DOUBLE, 'kd', None, None, ),  # 8
)


class servoj_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_pose_result)
servoj_pose_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servol_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - q_near
     - tool
     - wobj
     - kp
     - kd

    """


    def __init__(self, pose_list=None, v=None, a=None, q_near=None, tool=None, wobj=None, kp=None, kd=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.kp = kp
        self.kd = kd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype472, _size469) = iprot.readListBegin()
                    for _i473 in range(_size469):
                        _elem474 = iprot.readDouble()
                        self.pose_list.append(_elem474)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype478, _size475) = iprot.readListBegin()
                    for _i479 in range(_size475):
                        _elem480 = iprot.readDouble()
                        self.q_near.append(_elem480)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servol_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter481 in self.pose_list:
                oprot.writeDouble(iter481)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter482 in self.q_near:
                oprot.writeDouble(iter482)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 5)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 6)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 7)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 8)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servol_args)
servol_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRING, 'tool', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'wobj', 'UTF8', None, ),  # 6
    (7, TType.DOUBLE, 'kp', None, None, ),  # 7
    (8, TType.DOUBLE, 'kd', None, None, ),  # 8
)


class servol_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servol_result)
servol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class teach_mode_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('teach_mode_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(teach_mode_args)
teach_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class teach_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('teach_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(teach_mode_result)
teach_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class end_teach_mode_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_teach_mode_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_teach_mode_args)
end_teach_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class end_teach_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_teach_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_teach_mode_result)
end_teach_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_add_signal_args(object):
    """
    Attributes:
     - ip
     - slave_number
     - signal_address
     - signal_type
     - signal_name

    """


    def __init__(self, ip=None, slave_number=None, signal_address=None, signal_type=None, signal_name=None,):
        self.ip = ip
        self.slave_number = slave_number
        self.signal_address = signal_address
        self.signal_type = signal_type
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.slave_number = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.signal_address = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.signal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_add_signal_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.slave_number is not None:
            oprot.writeFieldBegin('slave_number', TType.I32, 2)
            oprot.writeI32(self.slave_number)
            oprot.writeFieldEnd()
        if self.signal_address is not None:
            oprot.writeFieldBegin('signal_address', TType.I32, 3)
            oprot.writeI32(self.signal_address)
            oprot.writeFieldEnd()
        if self.signal_type is not None:
            oprot.writeFieldBegin('signal_type', TType.I32, 4)
            oprot.writeI32(self.signal_type)
            oprot.writeFieldEnd()
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 5)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_add_signal_args)
modbus_add_signal_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'slave_number', None, None, ),  # 2
    (3, TType.I32, 'signal_address', None, None, ),  # 3
    (4, TType.I32, 'signal_type', None, None, ),  # 4
    (5, TType.STRING, 'signal_name', 'UTF8', None, ),  # 5
)


class modbus_add_signal_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_add_signal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_add_signal_result)
modbus_add_signal_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_delete_signal_args(object):
    """
    Attributes:
     - signal_name

    """


    def __init__(self, signal_name=None,):
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_delete_signal_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_delete_signal_args)
modbus_delete_signal_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
)


class modbus_delete_signal_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_delete_signal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_delete_signal_result)
modbus_delete_signal_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_read_args(object):
    """
    Attributes:
     - signal_name

    """


    def __init__(self, signal_name=None,):
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_read_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_read_args)
modbus_read_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
)


class modbus_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_read_result)
modbus_read_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_write_args(object):
    """
    Attributes:
     - signal_name
     - value

    """


    def __init__(self, signal_name=None, value=None,):
        self.signal_name = signal_name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_args)
modbus_write_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class modbus_write_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_result)
modbus_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_set_frequency_args(object):
    """
    Attributes:
     - signal_name
     - frequence

    """


    def __init__(self, signal_name=None, frequence=None,):
        self.signal_name = signal_name
        self.frequence = frequence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.frequence = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_set_frequency_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        if self.frequence is not None:
            oprot.writeFieldBegin('frequence', TType.I32, 2)
            oprot.writeI32(self.frequence)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_set_frequency_args)
modbus_set_frequency_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'frequence', None, None, ),  # 2
)


class modbus_set_frequency_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_set_frequency_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_set_frequency_result)
modbus_set_frequency_result.thrift_spec = (
)


class get_last_error_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_last_error_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_last_error_args)
get_last_error_args.thrift_spec = (
)


class get_last_error_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype486, _size483) = iprot.readListBegin()
                    for _i487 in range(_size483):
                        _elem488 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem488)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_last_error_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter489 in self.success:
                oprot.writeString(iter489.encode('utf-8') if sys.version_info[0] == 2 else iter489)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_last_error_result)
get_last_error_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_noneblock_taskstate_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_noneblock_taskstate_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_noneblock_taskstate_args)
get_noneblock_taskstate_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
)


class get_noneblock_taskstate_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_noneblock_taskstate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_noneblock_taskstate_result)
get_noneblock_taskstate_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class log_info_args(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_info_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_info_args)
log_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)


class log_info_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_info_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_info_result)
log_info_result.thrift_spec = (
)


class log_error_args(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_error_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_error_args)
log_error_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)


class log_error_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_error_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_error_result)
log_error_result.thrift_spec = (
)


class simulation_args(object):
    """
    Attributes:
     - sim
     - block

    """


    def __init__(self, sim=None, block=None,):
        self.sim = sim
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.sim = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simulation_args')
        if self.sim is not None:
            oprot.writeFieldBegin('sim', TType.BOOL, 1)
            oprot.writeBool(self.sim)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simulation_args)
simulation_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'sim', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class simulation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simulation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simulation_result)
simulation_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speed_args(object):
    """
    Attributes:
     - val

    """


    def __init__(self, val=None,):
        self.val = val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.val = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_args')
        if self.val is not None:
            oprot.writeFieldBegin('val', TType.DOUBLE, 1)
            oprot.writeDouble(self.val)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_args)
speed_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'val', None, None, ),  # 1
)


class speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_result)
speed_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_robot_state_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_state_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_state_args)
get_robot_state_args.thrift_spec = (
)


class get_robot_state_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype493, _size490) = iprot.readListBegin()
                    for _i494 in range(_size490):
                        _elem495 = iprot.readByte()
                        self.success.append(_elem495)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_state_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter496 in self.success:
                oprot.writeByte(iter496)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_state_result)
get_robot_state_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class get_flange_pose_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_pose_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_pose_args)
get_flange_pose_args.thrift_spec = (
)


class get_flange_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype500, _size497) = iprot.readListBegin()
                    for _i501 in range(_size497):
                        _elem502 = iprot.readDouble()
                        self.success.append(_elem502)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter503 in self.success:
                oprot.writeDouble(iter503)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_pose_result)
get_flange_pose_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_flange_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_speed_args)
get_flange_speed_args.thrift_spec = (
)


class get_flange_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype507, _size504) = iprot.readListBegin()
                    for _i508 in range(_size504):
                        _elem509 = iprot.readDouble()
                        self.success.append(_elem509)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter510 in self.success:
                oprot.writeDouble(iter510)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_speed_result)
get_flange_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_flange_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_acceleration_args)
get_flange_acceleration_args.thrift_spec = (
)


class get_flange_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readDouble()
                        self.success.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter517 in self.success:
                oprot.writeDouble(iter517)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_acceleration_result)
get_flange_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_pose_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_args)
get_tcp_pose_args.thrift_spec = (
)


class get_tcp_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype521, _size518) = iprot.readListBegin()
                    for _i522 in range(_size518):
                        _elem523 = iprot.readDouble()
                        self.success.append(_elem523)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter524 in self.success:
                oprot.writeDouble(iter524)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_result)
get_tcp_pose_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_speed_args)
get_tcp_speed_args.thrift_spec = (
)


class get_tcp_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readDouble()
                        self.success.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter531 in self.success:
                oprot.writeDouble(iter531)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_speed_result)
get_tcp_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_acceleration_args)
get_tcp_acceleration_args.thrift_spec = (
)


class get_tcp_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = iprot.readDouble()
                        self.success.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter538 in self.success:
                oprot.writeDouble(iter538)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_acceleration_result)
get_tcp_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_force_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_args)
get_tcp_force_args.thrift_spec = (
)


class get_tcp_force_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype542, _size539) = iprot.readListBegin()
                    for _i543 in range(_size539):
                        _elem544 = iprot.readDouble()
                        self.success.append(_elem544)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter545 in self.success:
                oprot.writeDouble(iter545)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_result)
get_tcp_force_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_position_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_position_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_position_args)
get_actual_joints_position_args.thrift_spec = (
)


class get_actual_joints_position_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype549, _size546) = iprot.readListBegin()
                    for _i550 in range(_size546):
                        _elem551 = iprot.readDouble()
                        self.success.append(_elem551)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_position_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter552 in self.success:
                oprot.writeDouble(iter552)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_position_result)
get_actual_joints_position_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_position_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_position_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_position_args)
get_target_joints_position_args.thrift_spec = (
)


class get_target_joints_position_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype556, _size553) = iprot.readListBegin()
                    for _i557 in range(_size553):
                        _elem558 = iprot.readDouble()
                        self.success.append(_elem558)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_position_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter559 in self.success:
                oprot.writeDouble(iter559)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_position_result)
get_target_joints_position_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_speed_args)
get_actual_joints_speed_args.thrift_spec = (
)


class get_actual_joints_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype563, _size560) = iprot.readListBegin()
                    for _i564 in range(_size560):
                        _elem565 = iprot.readDouble()
                        self.success.append(_elem565)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter566 in self.success:
                oprot.writeDouble(iter566)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_speed_result)
get_actual_joints_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_speed_args)
get_target_joints_speed_args.thrift_spec = (
)


class get_target_joints_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype570, _size567) = iprot.readListBegin()
                    for _i571 in range(_size567):
                        _elem572 = iprot.readDouble()
                        self.success.append(_elem572)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter573 in self.success:
                oprot.writeDouble(iter573)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_speed_result)
get_target_joints_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_acceleration_args)
get_actual_joints_acceleration_args.thrift_spec = (
)


class get_actual_joints_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype577, _size574) = iprot.readListBegin()
                    for _i578 in range(_size574):
                        _elem579 = iprot.readDouble()
                        self.success.append(_elem579)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter580 in self.success:
                oprot.writeDouble(iter580)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_acceleration_result)
get_actual_joints_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_acceleration_args)
get_target_joints_acceleration_args.thrift_spec = (
)


class get_target_joints_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype584, _size581) = iprot.readListBegin()
                    for _i585 in range(_size581):
                        _elem586 = iprot.readDouble()
                        self.success.append(_elem586)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter587 in self.success:
                oprot.writeDouble(iter587)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_acceleration_result)
get_target_joints_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_torque_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_torque_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_torque_args)
get_actual_joints_torque_args.thrift_spec = (
)


class get_actual_joints_torque_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype591, _size588) = iprot.readListBegin()
                    for _i592 in range(_size588):
                        _elem593 = iprot.readDouble()
                        self.success.append(_elem593)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_torque_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter594 in self.success:
                oprot.writeDouble(iter594)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_torque_result)
get_actual_joints_torque_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_torque_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_torque_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_torque_args)
get_target_joints_torque_args.thrift_spec = (
)


class get_target_joints_torque_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype598, _size595) = iprot.readListBegin()
                    for _i599 in range(_size595):
                        _elem600 = iprot.readDouble()
                        self.success.append(_elem600)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_torque_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter601 in self.success:
                oprot.writeDouble(iter601)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_torque_result)
get_target_joints_torque_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class stop_record_track_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_record_track_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_record_track_args)
stop_record_track_args.thrift_spec = (
)


class stop_record_track_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_record_track_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_record_track_result)
stop_record_track_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class start_record_track_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_record_track_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_record_track_args)
start_record_track_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class start_record_track_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_record_track_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_record_track_result)
start_record_track_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class collision_detect_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detect_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detect_args)
collision_detect_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
)


class collision_detect_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detect_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detect_result)
collision_detect_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class replay_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replay_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replay_args)
replay_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class replay_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replay_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replay_result)
replay_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_load_data_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype605, _size602) = iprot.readListBegin()
                    for _i606 in range(_size602):
                        _elem607 = iprot.readDouble()
                        self.value.append(_elem607)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_load_data_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.value))
            for iter608 in self.value:
                oprot.writeDouble(iter608)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_load_data_args)
set_load_data_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'value', (TType.DOUBLE, None, False), None, ),  # 1
)


class set_load_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_load_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_load_data_result)
set_load_data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_start_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_start_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_start_args)
fc_start_args.thrift_spec = (
)


class fc_start_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_start_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_start_result)
fc_start_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_stop_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_stop_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_stop_args)
fc_stop_args.thrift_spec = (
)


class fc_stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_stop_result)
fc_stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_config_args(object):
    """
    Attributes:
     - direction
     - ref_ft
     - damp
     - max_vel
     - number_list
     - tool
     - wobj
     - value

    """


    def __init__(self, direction=None, ref_ft=None, damp=None, max_vel=None, number_list=None, tool=None, wobj=None, value=None,):
        self.direction = direction
        self.ref_ft = ref_ft
        self.damp = damp
        self.max_vel = max_vel
        self.number_list = number_list
        self.tool = tool
        self.wobj = wobj
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype612, _size609) = iprot.readListBegin()
                    for _i613 in range(_size609):
                        _elem614 = iprot.readBool()
                        self.direction.append(_elem614)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype618, _size615) = iprot.readListBegin()
                    for _i619 in range(_size615):
                        _elem620 = iprot.readDouble()
                        self.ref_ft.append(_elem620)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.damp = []
                    (_etype624, _size621) = iprot.readListBegin()
                    for _i625 in range(_size621):
                        _elem626 = iprot.readDouble()
                        self.damp.append(_elem626)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.max_vel = []
                    (_etype630, _size627) = iprot.readListBegin()
                    for _i631 in range(_size627):
                        _elem632 = iprot.readDouble()
                        self.max_vel.append(_elem632)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.number_list = []
                    (_etype636, _size633) = iprot.readListBegin()
                    for _i637 in range(_size633):
                        _elem638 = iprot.readDouble()
                        self.number_list.append(_elem638)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_config_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter639 in self.direction:
                oprot.writeBool(iter639)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter640 in self.ref_ft:
                oprot.writeDouble(iter640)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.damp is not None:
            oprot.writeFieldBegin('damp', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.damp))
            for iter641 in self.damp:
                oprot.writeDouble(iter641)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_vel is not None:
            oprot.writeFieldBegin('max_vel', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.max_vel))
            for iter642 in self.max_vel:
                oprot.writeDouble(iter642)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.number_list is not None:
            oprot.writeFieldBegin('number_list', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.number_list))
            for iter643 in self.number_list:
                oprot.writeDouble(iter643)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 8)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_config_args)
fc_config_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'damp', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'max_vel', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.LIST, 'number_list', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.I32, 'value', None, None, ),  # 8
)


class fc_config_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_config_result)
fc_config_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_move_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_move_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_move_args)
fc_move_args.thrift_spec = (
)


class fc_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_move_result)
fc_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_guard_act_args(object):
    """
    Attributes:
     - direction
     - ref_ft
     - tool
     - wobj
     - type

    """


    def __init__(self, direction=None, ref_ft=None, tool=None, wobj=None, type=None,):
        self.direction = direction
        self.ref_ft = ref_ft
        self.tool = tool
        self.wobj = wobj
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype647, _size644) = iprot.readListBegin()
                    for _i648 in range(_size644):
                        _elem649 = iprot.readBool()
                        self.direction.append(_elem649)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype653, _size650) = iprot.readListBegin()
                    for _i654 in range(_size650):
                        _elem655 = iprot.readDouble()
                        self.ref_ft.append(_elem655)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_act_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter656 in self.direction:
                oprot.writeBool(iter656)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter657 in self.ref_ft:
                oprot.writeDouble(iter657)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 3)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 4)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_act_args)
fc_guard_act_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.STRING, 'tool', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'wobj', 'UTF8', None, ),  # 4
    (5, TType.I32, 'type', None, None, ),  # 5
)


class fc_guard_act_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_act_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_act_result)
fc_guard_act_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_guard_deact_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_deact_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_deact_args)
fc_guard_deact_args.thrift_spec = (
)


class fc_guard_deact_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_deact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_deact_result)
fc_guard_deact_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_force_set_value_args(object):
    """
    Attributes:
     - direction
     - ref_ft

    """


    def __init__(self, direction=None, ref_ft=None,):
        self.direction = direction
        self.ref_ft = ref_ft

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype661, _size658) = iprot.readListBegin()
                    for _i662 in range(_size658):
                        _elem663 = iprot.readBool()
                        self.direction.append(_elem663)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype667, _size664) = iprot.readListBegin()
                    for _i668 in range(_size664):
                        _elem669 = iprot.readDouble()
                        self.ref_ft.append(_elem669)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_force_set_value_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter670 in self.direction:
                oprot.writeBool(iter670)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter671 in self.ref_ft:
                oprot.writeDouble(iter671)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_force_set_value_args)
fc_force_set_value_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
)


class fc_force_set_value_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_force_set_value_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_force_set_value_result)
fc_force_set_value_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_pos_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype675, _size672) = iprot.readListBegin()
                    for _i676 in range(_size672):
                        _elem677 = iprot.readDouble()
                        self.middle.append(_elem677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype681, _size678) = iprot.readListBegin()
                    for _i682 in range(_size678):
                        _elem683 = iprot.readDouble()
                        self.range.append(_elem683)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_pos_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter684 in self.middle:
                oprot.writeDouble(iter684)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter685 in self.range:
                oprot.writeDouble(iter685)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_pos_args)
fc_wait_pos_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_pos_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_pos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_pos_result)
fc_wait_pos_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_vel_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype689, _size686) = iprot.readListBegin()
                    for _i690 in range(_size686):
                        _elem691 = iprot.readDouble()
                        self.middle.append(_elem691)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype695, _size692) = iprot.readListBegin()
                    for _i696 in range(_size692):
                        _elem697 = iprot.readDouble()
                        self.range.append(_elem697)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_vel_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter698 in self.middle:
                oprot.writeDouble(iter698)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter699 in self.range:
                oprot.writeDouble(iter699)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_vel_args)
fc_wait_vel_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_vel_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_vel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_vel_result)
fc_wait_vel_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_ft_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype703, _size700) = iprot.readListBegin()
                    for _i704 in range(_size700):
                        _elem705 = iprot.readDouble()
                        self.middle.append(_elem705)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype709, _size706) = iprot.readListBegin()
                    for _i710 in range(_size706):
                        _elem711 = iprot.readDouble()
                        self.range.append(_elem711)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_ft_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter712 in self.middle:
                oprot.writeDouble(iter712)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter713 in self.range:
                oprot.writeDouble(iter713)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_ft_args)
fc_wait_ft_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_ft_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_ft_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_ft_result)
fc_wait_ft_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_logic_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype717, _size714) = iprot.readListBegin()
                    for _i718 in range(_size714):
                        _elem719 = iprot.readI32()
                        self.value.append(_elem719)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_logic_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.value))
            for iter720 in self.value:
                oprot.writeI32(iter720)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_logic_args)
fc_wait_logic_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'value', (TType.I32, None, False), None, ),  # 1
)


class fc_wait_logic_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_logic_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_logic_result)
fc_wait_logic_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_get_ft_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_get_ft_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_get_ft_args)
fc_get_ft_args.thrift_spec = (
)


class fc_get_ft_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype724, _size721) = iprot.readListBegin()
                    for _i725 in range(_size721):
                        _elem726 = iprot.readDouble()
                        self.success.append(_elem726)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_get_ft_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter727 in self.success:
                oprot.writeDouble(iter727)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_get_ft_result)
fc_get_ft_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class fc_mode_is_active_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_mode_is_active_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_mode_is_active_args)
fc_mode_is_active_args.thrift_spec = (
)


class fc_mode_is_active_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_mode_is_active_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_mode_is_active_result)
fc_mode_is_active_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class start_realtime_mode_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_realtime_mode_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_realtime_mode_args)
start_realtime_mode_args.thrift_spec = (
)


class start_realtime_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_realtime_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_realtime_mode_result)
start_realtime_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class end_realtime_mode_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_realtime_mode_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_realtime_mode_args)
end_realtime_mode_args.thrift_spec = (
)


class end_realtime_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_realtime_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_realtime_mode_result)
end_realtime_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_speed_optimization_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_speed_optimization_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_speed_optimization_args)
enable_speed_optimization_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class enable_speed_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_speed_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_speed_optimization_result)
enable_speed_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_speed_optimization_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_speed_optimization_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_speed_optimization_args)
disable_speed_optimization_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class disable_speed_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_speed_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_speed_optimization_result)
disable_speed_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

